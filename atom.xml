<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZYM&#39;Blog</title>
  
  <subtitle>To learn, to be strong</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zymdragonggg.github.io/"/>
  <updated>2020-10-13T12:09:46.840Z</updated>
  <id>http://zymdragonggg.github.io/</id>
  
  <author>
    <name>Amanda Z</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python面试知识点总结（二）</title>
    <link href="http://zymdragonggg.github.io/2020/10/13/python%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://zymdragonggg.github.io/2020/10/13/python%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-10-13T11:27:13.000Z</published>
    <updated>2020-10-13T12:09:46.840Z</updated>
    
    <content type="html"><![CDATA[<p>秋招以来，为了找工作又学习了很多python相关的知识，给大家分享一下，里面好多内容都是我东拼西凑出来的（如果是借鉴了其他博客的，希望大家可以指出，我会标注上），感觉都是比较常见的或者被问到的。</p><p>希望这篇分享会对大家找工作有所帮助～</p><a id="more"></a><h2 id="gil及多线程相关">1. GIL及多线程相关</h2><ul><li><p><strong>背景概念：</strong></p><ul><li><strong>支持多线程：</strong>不同线程对共享资源访问的互斥</li><li><strong>多线程带来的问题：</strong>多线程是可以共享变量的，同时执行可能会导致数据被污染造成数据混乱，这是线程的不安全性，引入互斥锁。</li><li><strong>互斥锁：</strong>确保某段关键的代码数据只能有一个线程从头到尾完整执行，保证了这段代码数据的安全性，但是这也会导致死锁。</li><li><strong>死锁：</strong>多个子线程在等待对方解除占用状态，但是都不先解锁，互相等待，导致死锁。</li></ul></li><li><p><strong>python中的多线程</strong></p><ul><li><p><strong>GIL锁（Global Interpreter Lock）</strong>：为了利用多核，python开始支持多线程，解决多线程之间数据完整性和状态同步的最简单方法就是加锁，GIL是Python的全局解释器锁，GIL<strong>确保每次只能执行一个“线程”</strong>。一个线程获取GIL执行相关操作，然后将GIL传递到下一个线程。</p></li><li><p>虽然看起来程序被多线程并行执行，但它们实际上只是轮流使用相同的CPU核心。所有这些GIL传递都增加了执行的开销。<strong>这意味着多线程并不能让程序运行的更快。</strong></p></li><li><p>同一进程中如有多个线程运行，一个线程在运行时会霸占python解释器，加了一把锁即GIL，使该进程内的其他线程无法运行，等该线程运行完后其他线程才运行，如果线程运行过程中<em>遇到耗时的操作</em>（阻塞），则解释器锁解开，使其他线程运行，所以在多线程中，<strong>线程的运行仍然是有先后顺序的，并不是同时进行的</strong>。在同一时刻，只能有一个线程在一个cpu上执行字节码，没法像C和JAVA一样将多个线程映射到多个CPU上执行，但是GIL<strong>会根据执行的字节码行数和时间片以及遇到的IO操作的时候主动释放锁</strong>，让其他字节码进行。多线程爬取单线程性能有所提升，因为遇到IO操作阻塞会释放GIL锁，会在合适的时间转换到其他线程执行。</p></li><li><p><strong>基于GIL的存在，在遇到大量IO操作代码时，使用多线程效率更高。</strong></p></li><li><p>计算密集型（大量计算不停止一直算），用多进程</p></li><li><p>IO密集型（读写），用线程（利用等待的时间加速），<strong>协程也是适合io密集型</strong></p></li><li><p><strong>多线程怎么使用多核：</strong> 1、重写python编译器(官方cpython)如使用：PyPy解释器 2、调用C语言的链接库</p><blockquote><p>明确GIL不是Python的特性，是实现Python解析器（Cpython）时引入的一个概念，python的解析器还有Pypy、psyco等，大部分环境下默认是Python的执行环境。</p></blockquote></li></ul></li></ul><h2 id="python多线程多进程实践"><strong>2. python多线程、多进程实践</strong></h2><p>1）背景知识概念</p><ul><li><p><strong>多任务</strong>：同一时间执行多个任务，可以充分利用计算资源，提升执行效率</p><ul><li><p>多任务执行方式：</p><ul><li><strong>并发：</strong>在一段时间内<strong>交替</strong>（时间非常短）去执行多个任务，<strong>单核CPU处理多任务</strong>，操作系统轮流让各个任务交替的执行。<strong>任务数量大于CPU核心数</strong></li><li><strong>并行：</strong>在一段时间内<strong>真正的同时一起执行</strong>多个任务，<strong>多核CPU</strong>，操作系统给CPU的每一个内核安排一个执行的任务，多个内核一起同时执行任务，<strong>任务数量小于或者等于CPU核心数</strong></li></ul></li></ul></li></ul><p>2）在python中想要实现多任务，需要使用多进程来完成</p><ul><li>进程是操作系统资源分配（内存、磁盘、网络）的最小单位，是一个运行的程序，如正在运行的QQ、微信等。一个运行的程序至少有一个进程</li><li><p>没有多进程时候是只有一个主进程，多进程的时候是额外创建多个子进程</p></li><li><p><strong>python多进程实践</strong></p></li><li><p>```python # 导入包 import multiprocessing</p><h1 id="创建进程对象">创建进程对象</h1><p>进程对象 = multiprocessing.Process(target = 任务名字（函数名、方法名）)</p><p>#Process还有两个属性： name,给进程指定一个名字，通常系统会自动给出名字，group，进程组，目前只能使用None。</p><h1 id="启动进程执行任务">启动进程执行任务</h1><p>进程对象.start() <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 进程执行带有参数的任务</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;python</span><br><span class="line">  import multiprocessing</span><br><span class="line">  import time</span><br><span class="line">  </span><br><span class="line">  def sing(num):</span><br><span class="line">      for i in range(num):</span><br><span class="line">          print(&#39;i am singing&#39;)</span><br><span class="line">          time.sleep(0.5)</span><br><span class="line">  </span><br><span class="line">  def dance(num):</span><br><span class="line">      for i in range(num):</span><br><span class="line">          print(&#39;i am dancing&#39;)</span><br><span class="line">          time.sleep(0.5)</span><br><span class="line">  </span><br><span class="line">  if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">      # args指定使用元组的方式给指定任务传参，按顺序传给任务传参，一定要和参数的顺序一致</span><br><span class="line">      # kwargs指定字典的方式给指定任务传参，key就是参数的名字，必须严格一致。按照key的名字传参。</span><br><span class="line">      p1 &#x3D; multiprocessing.Process(target &#x3D; sing,args&#x3D;(3,));</span><br><span class="line">      p2 &#x3D; multiprocessing.Process(target &#x3D; dance,kwargs&#x3D;&#123;&#39;num&#39;:2&#125;);</span><br><span class="line">      p1.start()</span><br><span class="line">      p2.start()</span><br></pre></td></tr></table></figure></p></li><li><p>对进程的管理-获取进程编号</p><p><code>import os</code> 获取当前进程编号<code>pidos.getpid()</code>,获取当前进程父进程的编号<code>pidos.getppid()</code></p><p><img src="https://i.loli.net/2020/09/03/FAkYdj1mar5bliZ.png" /></p></li><li><p>守护主进程</p><p><em>主进程会等待所有的子进程执行结束再结束</em>，但是我们希望主进程结束，<strong>子进程也直接销毁，不再执行子进程中的代码</strong>，这就需要设置守护主进程：<code>子进程.daemon = True</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        print(<span class="string">'i am working'</span>)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = multiprocessing.Process(target = work, args=(<span class="number">20</span>,));</span><br><span class="line">    p.daemon = <span class="literal">True</span> <span class="comment"># 这个一定要放在start之前</span></span><br><span class="line">    p.start()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'work done!'</span>)</span><br></pre></td></tr></table></figure></li></ul><p>3）<strong>Python多线程</strong>：线程是程序执行的最小单位，共享同一个进程的资源，可以实现多任务。</p><ul><li><p>Python多线程实践：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入包</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建进程对象</span></span><br><span class="line">线程对象 = threading.Thread(target = 任务名字（函数名、方法名）)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Process还有两个属性： name,给线程指定一个名字，通常系统会自动给出名字，group，线程组，目前只能使用None。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动进程执行任务</span></span><br><span class="line">线程对象.start()</span><br></pre></td></tr></table></figure><p>整个都和多进程一样，可以试着去做一下线程执行带有参数的任务，和进程保持一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        print(<span class="string">'i am singing'</span>)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 下面是两种设置守护线程的方式</span></span><br><span class="line">    <span class="comment"># t = threading.Thread(target = sing,args=(10,), daemon=True);</span></span><br><span class="line">    t = threading.Thread(target = sing,args=(<span class="number">10</span>,));</span><br><span class="line">    t.setDaemon(<span class="literal">True</span>)</span><br><span class="line">    t.start()</span><br><span class="line">    </span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'well done!'</span>)</span><br></pre></td></tr></table></figure></li><li><p>多线程之间的执行是无序的，是由CPU调度决定的、操作系统决定的。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 让这个函数等待1秒在执行，相当于5个线程都创建好之后，一起等着开始执行后面的语句，会发现每次运行结果不相同</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 获取当前线程的线程对象</span></span><br><span class="line">    thread = threading.current_thread()</span><br><span class="line">    print(thread)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        sub_thread = threading.Thread(target=task)</span><br><span class="line">        sub_thread.start()</span><br></pre></td></tr></table></figure><p>4）关系对比</p><ul><li>线程依附在进程里面，没有进程就没有线程</li><li><p>一个进程默认提供一条线程，进程可以创建多个线程</p></li><li><p>区别对比</p><ul><li>创建进程的资源开销比创建线程的资源开销大</li><li>进程是操作系统资源分配的基本单位，线程是CPU调度的单位</li><li>线程不能独立运行，依附进程</li></ul></li><li><p>优缺点对比</p><ul><li>进程：开销大，可以利用多核</li><li>线程，开销小，不能用多核</li></ul></li></ul><p>首先，如果不做任何限制，主线程执行完，子线程再继续执行；如果加上守护进程，主线程执行完，子线程无法执行；利用Join()，主线程等子线程执行完毕再执行（join所完成的工作就是线程同步，即主线程任务结束之后，进入阻塞状态，一直等待其他的子线程执行结束之后，主线程在终止）</p><blockquote><p>join有一个timeout参数：</p><ol type="1"><li>当设置守护线程时，含义是主线程对于子线程等待timeout的时间将会杀死该子线程，最后退出程序。所以说，如果有10个子线程，全部的等待时间就是每个timeout的累加和。简单的来说，就是给每个子线程一个timeout的时间，让他去执行，时间一到，不管任务有没有完成，直接杀死。</li><li>没有设置守护线程时，主线程将会等待timeout的累加和这样的一段时间，时间一到，主线程结束，但是并没有杀死子线程，子线程依然可以继续执行，直到子线程全部结束，程序退出。</li></ol></blockquote><p>5）pyton多进程、线程、协程，多进程怎么通信</p><ul><li><p>协程</p><p>线程是系统级别的，它们是由操作系统调度；协程是程序级别的，由程序员根据需要自己调度。我们把一个线程中的一个个函数叫做子程序，那么子程序在执行过程中可以中断去执行别的子程序；别的子程序也可以中断回来继续执行之前的子程序，这就是<strong>协程</strong>。也就是说同一线程下的一段代码&lt;1&gt;执行着执行着就可以中断，然后跳去执行另一段代码，当再次回来执行代码块&lt;1&gt;的时候，接着从之前中断的地方开始执行。</p><ul><li>yield实现协程</li><li>greenlet,手动切换</li><li>gevent实现协程：第三方库</li></ul></li><li><p>通信</p><ul><li>pip：适用于两个进程一个读一个写的单双工情况，信息是一个方向的流动 ，读写效率高于queue</li><li>queue：多个进程进行读或者多个进程进行写</li></ul><p>在一个进程中，不同子线程负责不同的任务，t1子线程负责获取到数据，t2子线程负责把数据保存的本地，那么<strong>他们之间的通信使用Queue来完成</strong>。因为再一个进程中，数据变量是共享的，即<strong>多个子线程可以对同一个全局变量进行操作修改</strong>，<strong>Queue是加了锁的安全消息队列</strong>。</p></li></ul><p>6）线程同步</p><p>如果没有控制多个线程对同一资源的访问，对数据造成破坏，使得线程运行的结果不可预期，这种现象称为“线程不安全”</p><p>同步的意思是：进程或线程A和B一块配合，A执行到1一定程度的时候要依靠B的某个结果，于是停下来，示意B运行；B运行后，再将结果传给A；A再继续操作。</p><ul><li><p>线程锁实现同步控制</p><p>线程锁使用threading.Lock()实例化，使用acquire()上锁，使用release()释放锁，acquire()和release()必须同时成对存在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> l1.acquire():</span><br><span class="line">            <span class="comment"># 如果第一把锁上锁了</span></span><br><span class="line">            print(<span class="string">'我是老大，我先运行'</span>)</span><br><span class="line">            l2.release()</span><br><span class="line">            <span class="comment"># 释放第二把锁</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> l2.acquire():</span><br><span class="line">            <span class="comment"># 如果第二把锁上锁了</span></span><br><span class="line">            print(<span class="string">'我是老二，我第二运行'</span>)</span><br><span class="line">            l3.release()</span><br><span class="line">            <span class="comment"># 释放第三把锁</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run3</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> l3.acquire():</span><br><span class="line">            <span class="comment"># 如果第三把锁上锁了</span></span><br><span class="line">            print(<span class="string">'我是老三，我最后运行'</span>)</span><br><span class="line">            l1.release()</span><br><span class="line">            <span class="comment"># 释放第一把锁</span></span><br><span class="line">t1 = threading.Thread(target=run1)</span><br><span class="line">t2 = threading.Thread(target=run2)</span><br><span class="line">t3 = threading.Thread(target=run3)</span><br><span class="line"></span><br><span class="line">l1 = threading.Lock()</span><br><span class="line">l2 = threading.Lock()</span><br><span class="line">l3 = threading.Lock()</span><br><span class="line"><span class="comment"># 实例化三把锁</span></span><br><span class="line"></span><br><span class="line">l2.acquire()</span><br><span class="line">l3.acquire()</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t3.start()</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">我是老大，我先运行</span><br><span class="line">我是老二，我第二运行</span><br><span class="line">我是老三，我最后运行</span><br><span class="line">我是老大，我先运行</span><br><span class="line">我是老二，我第二运行</span><br><span class="line">我是老三，我最后运行</span><br><span class="line">我是老大，我先运行</span><br><span class="line">我是老二，我第二运行</span><br><span class="line">我是老三，我最后运行</span><br><span class="line">.....</span><br></pre></td></tr></table></figure></li><li><p>条件变量实现同步精准控制</p><p>信号量实现定量的线程同步</p><p>semaphore适用于控制进入数量的锁，好比文件的读写操作，写入的时候一般只用一个线程写，如果多个线程同时执行写入操作的时候，会造成写入数据混乱，读取的时候可以用多个线程读取，即写与写是互斥的，读与写不是互斥的，读与读不是互斥的。</p><p>BoundedSemaphore，这种锁允许一定数量的线程同时更改数据，不是互斥锁。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n, se)</span>:</span></span><br><span class="line">    se.acquire()</span><br><span class="line">    print(<span class="string">"run the thread: %s"</span> % n)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    se.release()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置允许5个线程同时运行</span></span><br><span class="line">semaphore = threading.BoundedSemaphore(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(i,semaphore))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><p>运行后，即5个一批的线程被放行，用来控制进入某段代码的线程数量</p></li></ul><h2 id="map函数和reduce函数">3. map函数和reduce函数</h2><p>map函数返回的是一个生成器。map函数的第一个参数是function,第二个参数一般是list，第三个参数可以是List，也可以不写。通过函数function依次作用在list上的每个元素，得到一个新的List返回。</p><p><img src="https://i.loli.net/2020/09/03/a4uMQZg1Bycjh9s.png" /></p><p>reduce函数的参数必须接受两个参数，reduce()函数将传入的函数作用在序列的第一个元素得到结果后，把这个结果继续与下一个元素作用（累积计算），最终结果是所有的元素相互作用的结果。</p><p><img src="https://i.loli.net/2020/08/26/CHdG9iS7r5heyBn.png" /></p><p><img src="/Users/m/Documents/Blog/source/_posts/C:\Users\M\AppData\Roaming\Typora\typora-user-images\image-20200806100010605.png" /></p><p><strong>map函数省去了for循环的过程，lambda省去了定义函数</strong></p><h2 id="python中断言">4. python中断言</h2><p>Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。</p><p>用来检查一个条件，如果为真，就不做任何事情，如果为假，提示<strong>assertionError异常信息</strong></p><p>断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况，例如我们的代码只能在 Linux 系统下运行，可以先判断当前系统是否符合条件。</p><p><img src="https://i.loli.net/2020/08/26/AausiXQr9hq4ot3.png" /></p><h2 id="python2和3的区别">5. Python2和3的区别</h2><ul><li>python3使用Print必须加小括号打印内容，python2既可以使用带小括号的方式，也可以使用一个空格来分隔打印内容</li><li>python2中的range是生成一个列表 range(3)--&gt;[0,1,2], xrange是一个生成器，python3中的range是一个可迭代对象，既不是生成器也不是迭代器</li><li>python2中使用ASCII编码，python使用UTF-8编码</li><li>python2中unicode表示字符串序列，str表示字节序列，python2中str表示字符串序列，byte表示字节序列</li><li>python2中为正常显示中文，引入coding声明,python3不需要</li><li>python2中是raw_input()，python3中是Input()函数</li><li>python2中除法是默认向下取整，为整型，python3是正常除法，为浮点型</li><li>python2中的字典使用开放地址法解决冲突，python3用的是链地址法</li></ul><h2 id="异常捕获和处理">6. 异常捕获和处理</h2><ul><li><p>常见异常</p><p>AttributeError 属性异常 比如foo.x，但是foo没有x属性</p><p>IOError 输入输出异常，基本上是无法打开文件</p><p>ImportError 无法引入模块或包；基本上是路径问题或名称错误 IndentationError 语法错误（的子类） ；代码没有正确对齐 IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5] KeyError 试图访问字典里不存在的键 KeyboardInterrupt Ctrl+C被按下 NameError 使用一个还未被赋予对象的变量 SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了） TypeError 传入对象类型与要求的不符合 UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，导致你以为正在访问它 ValueError 传入一个调用者不期望的值，即使值的类型是正确的</p></li><li><p>捕捉异常可以使用try/except语句。</p></li><li><p>try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">&lt;语句&gt;        <span class="comment">#运行别的代码</span></span><br><span class="line"><span class="keyword">except</span> &lt;名字&gt;：</span><br><span class="line">&lt;语句&gt;        <span class="comment">#如果在try部份引发了'name'异常</span></span><br><span class="line"><span class="keyword">except</span> &lt;名字&gt;，&lt;数据&gt;:</span><br><span class="line">&lt;语句&gt;        <span class="comment">#如果引发了'name'异常，获得附加的数据</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">&lt;语句&gt;        <span class="comment">#如果没有异常发生</span></span><br></pre></td></tr></table></figure></li><li><p>使用except而不带任何异常类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    正常的操作</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    发生异常，执行这块代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    如果没有异常执行这块代码</span><br></pre></td></tr></table></figure><p><strong>以上方式try-except语句捕获所有发生的异常。但这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息。因为它捕获所有的异常。</strong></p></li><li><p>try-finally 语句</p><p>try-finally 语句无论是否发生异常都将执行最后的代码。</p></li><li><p>触发异常</p><p><code>raise</code>语句自己触发异常，触发以后不再执行后面的语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionName</span><span class="params">( level )</span>:</span></span><br><span class="line">    <span class="keyword">if</span> level &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"Invalid level!"</span>, level)</span><br><span class="line">        <span class="comment"># 触发异常后，后面的代码就不会再执行</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="提高python运行效率的方法">7. 提高python运行效率的方法</h2><ul><li><p>使用生成器，可以节约大量内存</p></li><li><p>循环代码优化，避免过多重复代码的执行</p></li><li><p>核心模块用Cpython PyPy等</p><blockquote><p>python没有专门机构负责实现，多个社区实现的。Cpython是C语言实现的Python，用java开发的JPython，Cpython使用解释执行的方式，性能差，但是PyPy是JIT(即时编译),性能上得到了提升。但是PyPy无法支持官方的C/Python API，无法使用Numpy或Scipy等第三方库。</p></blockquote></li></ul><blockquote></blockquote><ul><li><p>多进程、多线程、协程</p></li><li><p>多个if elif条件判断，可以把最优可能先发生的条件放到前面写，这样减少判断次数</p></li></ul><h2 id="python中的命名方式魔法方法">8. python中的命名方式、魔法方法</h2><p><strong>Python中一切皆对象，</strong>函数也不例外，函数作为对象可以赋值给一个变量、可以作为元素添加到集合对象中、可作为参数值传递给其它函数，还可以当做函数的返回值，这些特性就是第一类对象所特有的。</p><figure><img src="https://img-blog.csdn.net/20180122142356120?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmVpa29uMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="命名规约" /><figcaption>命名规约</figcaption></figure><p><strong>public类型</strong></p><ol type="1"><li>xx : 公用方法，公有变量没有以下划线开头的变量或者方法是public类型。</li><li>public类型可以被子类、类内以及类外被访问。</li><li>在python中数据和方法默认都是pubic类型的，此时方法和变量名都没有下划线。</li></ol><p><strong>protected类型</strong></p><ol type="1"><li>_xx : 半保护方法, 以单下划线开头表示的是protected类型的变量或者方法。</li><li>只有类对象和子类对象自己能够访问到这些变量，在模块或类外不可以使用，不能用from module import *导入，为了避免和子类的方法名称冲突，对于该标识符描述的方法，父类的方法不能轻易地被子类方法覆盖，他们的名字实际上是_classname_methodname</li></ol><p><strong>private类型</strong></p><p>1、 __xx :全私有，全保护，双下划线表示的是私有类型的变量或者方法。 2、private类型只能允许类内进行访问。 只能类对象自己访问，不能用from module import *导入。</p><p><strong>除此以外</strong></p><ul><li><strong>__object__ </strong> 内建方法，用户不要定义，python中的魔方方法</li><li><strong>xx_:</strong>用于避免和Python关键词冲突</li></ul><p><strong>魔方方法</strong></p><p>在Python中以<strong>两个下划线开头的方法</strong>，__init__、__str__、__doc__、__new__等，被称为&quot;魔术方法&quot;（Magic methods）。魔术方法在类或对象的某些事件出发后会自动执行，如果希望根据自己的程序定制自己特殊功能的类，那么就需要对这些方法进行重写。注意：Python 将所有以 __（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 __ 为前缀。</p><ol type="1"><li>__new__：<ul><li>在<strong>实例创建前被调用</strong>，其任务为创建实例然后返回该实例对象，是个<strong>静态方法</strong>创建对象时候执行的方法。</li><li><strong>至少有一个参数cls，代表当前类</strong>，此参数在实例化时由python自动识别</li><li><strong>必须要有返回值</strong>，返回实例化出的实例，返回值（实例）将传递给init方法的第一个参数（self）</li></ul></li><li>__init__:<ul><li>当<strong>实例对象创建完后被调用</strong>，然后设置对象属性的一些初始值，通常用在初始化一个类实例的时候，是一个实例方法。</li><li>init有一个参数self,这就是new返回的实例，init可以在new基础上完成一些其他初始化的动作，</li><li><strong>Init不需要返回值</strong></li></ul></li><li><p>__str__：使用Print输出对象的时候，只要自己定义了str方法，就会打印从这个方法中return的数据</p></li><li><p>__del__：删除对象执行的方法</p></li></ol><h2 id="python引用计数机制-垃圾回收机制-gc模块">9. python引用计数机制 垃圾回收机制 gc模块</h2><p>https://foofish.net/python-gc.html 这个博客讲的不错</p><p><strong>垃圾回收</strong></p><ul><li><p><strong>垃圾回收机制定义：</strong></p><p>垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要总启动垃圾回收。所以，Python只会在特定条件下，自动启动垃圾回收。当Python运行时，<strong>会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数</strong>，当两者的差值高于某个阈值时，垃圾回收才会启动。我们可以通过gc模块的get_threshold()方法，查看该阈值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">print(gc.get_threshold())</span><br></pre></td></tr></table></figure><p>返回(700, 10, 10)，后面的两个10是与分代回收相关的阈值，后面可以看到。700即是垃圾回收启动的阈值。可以通过gc中的set_threshold()方法重新设置。我们也可以手动启动垃圾回收，即使用gc.collect()。</p></li><li><p><strong>垃圾回收作用：</strong></p><ul><li>找到内存中无用的垃圾资源</li><li>清除这些垃圾并把内存让出来给其他对象使用</li><li>解决内存泄露问题：内存空间在使用完毕后未释放</li></ul></li></ul><p><strong>引用计数</strong>（Reference Counting）：</p><ul><li><p>引用计数定义及使用过程</p><ul><li><p>每个对象维护一个<code>ob_ref</code>字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，一旦对象的引<strong>用计数为0</strong>，该对象<strong>立即被回收，对象占用的内存空间将被释放</strong>。</p></li><li><p>引用次数增加：创建对象，对象被引用（赋值操作），对象作为参数传递到函数，对象作为元素存储到容器中。</p></li><li><p>它的<strong>缺点是</strong>需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是它不能解决对象的<strong>“循环引用”</strong>，因此，也有很多语言比如Java并没有采用该算法做来垃圾的收集机制。</p></li></ul></li><li><p><strong>循环引用</strong>：</p><ul><li><p>会使得引用对象的引用计数不能为0，然而这些对象实际上并没有被任何外部对象所引用，他们只是相互引用，A和B<strong>相互引用</strong>而再没有外部引用A与B中的任何一个，它们的引用计数虽然都为1，但显然应该被回收，例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">a = &#123;&#125; <span class="comment"># A引用计数为1</span></span><br><span class="line">b = &#123;&#125; <span class="comment"># B引用计数为2</span></span><br><span class="line">a[<span class="string">'b'</span>] = b <span class="comment"># B引用计数加1</span></span><br><span class="line">b[<span class="string">'a'</span>] = a <span class="comment"># A引用计数加1</span></span><br><span class="line">print(sys.getrefcount(a)) <span class="comment">#获取引用计数 输出为3因为a作为参数传给了getrefecount</span></span><br><span class="line">print(sys.getrefcount(b)) <span class="comment">#输出为3</span></span><br><span class="line"><span class="keyword">del</span> a <span class="comment"># a引用计数减一</span></span><br><span class="line"><span class="keyword">del</span> b <span class="comment"># b引用计数减一</span></span><br></pre></td></tr></table></figure><p>上述例子中，执行完del语句后，没有任何引用指向这两个对象，但是两个对象各包含一个对方对象的引用，但是都不能使用了，就可以理解为垃圾对象，但是引用计数都不为0，就不会被回收，留在内存中，就<strong>造成了内存泄露。由此引入标记-清楚和分代（隔代）回收两种gc机制</strong></p></li></ul></li></ul><p><strong>垃圾回收机制具体实现</strong></p><ul><li><p><strong>标记清楚</strong>（Mark-Sweep）</p><ul><li>标记清除（Mark—Sweep）算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：<ul><li><strong>标记阶段</strong>：GC把所有的『活动对象』打上标记</li><li><strong>回收阶段：</strong>把那些没有标记的对象『非活动对象』进行回收。</li></ul></li></ul><blockquote><p><strong>那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？</strong></p><p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。<strong>根对象就是全局变量、调用栈、寄存器。</strong></p></blockquote><ul><li><p>举例：</p><p>把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。</p></li></ul><p><img src="https://i.loli.net/2020/08/26/mEMZXS94Kv7qTBW.png" /></p><ul><li><p><strong>标记清除算法主要用处：</strong></p><p>作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于<strong>字符串、数值对象是不可能造成循环引用问题</strong>。Python使用一个双向链表将这些容器对象组织起来。</p></li><li><p>缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。</p></li></ul></li><li><p><strong>分代回收</strong></p><p>这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，<strong>对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。</strong></p><p>Python将<strong>所有的对象分为0，1，2三代</strong>。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。</p><p>这两个次数即上面get_threshold()返回的(700, 10, 10)返回的两个10。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。</p><p>同样可以用set_threshold()来调整，比如对2代对象进行更频繁的扫描。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">gc.set_threshold(<span class="number">700</span>, <span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>分代回收是一种以空间换时间的操作方式，Python<strong>将内存根据对象的存活时间划分为不同的集合</strong>，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代<strong>链表的总数达到上限</strong>时，<strong>Python垃圾收集机制就会被触发</strong>，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，<strong>分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象</strong></p></li><li><p>还有两种情况会触发GC机制：</p><ul><li><p>程序退出</p></li><li><p>调用gc.collect</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">gc.collect()</span><br><span class="line"><span class="comment"># 可以导入gc模块，时不时的回收内存，释放内存空间，充分利用分配的内存，避免程序跑到一半停止</span></span><br></pre></td></tr></table></figure><h2 id="内存管理机制">10. 内存管理机制</h2><ul><li>python中的内存管理由<strong>Python私有堆空间管理。</strong>所有Python对象和数据结构都位于私有堆中。程序员无权访问此私有堆。python解释器负责处理这个问题。</li></ul><p><strong>Python对象的堆空间分配由Python的内存管理器完成</strong>。核心API提供了一些程序员编写代码的工具。</p><p>Python还有一个内置的垃圾收集器，它可以回收所有未使用的内存，并使其可用于堆空间。</p><p><strong>Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。</strong></p><p>1，<strong>Pymalloc机制</strong>。为了加速Python的执行效率，Python<strong>引入了一个内存池机制</strong>，<strong>用于管理对小块内存的申请和释放</strong>。</p><p>2，Python中<strong>所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。</strong></p><p>3，对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就发不能再分配给浮点数。<strong>Python 对小整数的定义是 [-5, 257)</strong>，对于这个范围的数，不会新建对象，直接从小整数对象池中取就可以。</p><h2 id="文件打开模式">11. 文件打开模式</h2><p><code>text = oepn(filePath, 操作方式，编码方式）</code></p><p><img src="https://i.loli.net/2020/09/03/I8DlkJKPVAwjR9W.png" /></p><h2 id="单例模式">12. 单例模式</h2><p><strong>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，单例模式是一种对象创建型模式</strong>。简单的说就是保证只有一个对象，节约内存空间，我们可以通过修改类中的 <code>__new__</code>方法，实现一个简单的单例类。</p><p>什么情况下会用到：假如有很多地方都需要使用配置文件的内容，也就是说，很多地方都需要创建 AppConfig对象的实例，这就导致系统中存在多个AppConfig的实例对象，在配置文件内容很多的情况下会严重浪费内存资源。类似AppConfig这样的类，我们希望在程序运行期间只存在一个实例对象。</p><p>优点：速度快、在使用时不需要创建、直接使用即可。</p><p>缺点：可能存在内存浪费</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A.instance:</span><br><span class="line">            A.instance = super().__new__(cls)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">a = A()</span><br><span class="line">print(id(a))</span><br><span class="line">b = A()</span><br><span class="line">print(id(b))</span><br></pre></td></tr></table></figure><h2 id="python函数的嵌套闭包">13. python函数的嵌套、闭包</h2><ul><li><p><strong>函数嵌套</strong>：python允许在定义函数的时候，其函数体内又包含另外一个函数的完整定义。像这样定义在其他函数内的函数叫做内部函数，内部函数所在的函数叫做外部函数。</p></li><li><p><strong>自由变量</strong>：未在本地作用域中定义的变量。例如定义在内存函数外的外层函数的作用域中的变量。</p></li><li><p><strong>闭包</strong>：在一个外函数中定义一个内函数，<strong>内函数运用了外函数的临时变量</strong>，并且<strong>外函数的返回值是内函数的引用</strong>，这样就构成了一个闭包。</p><ul><li>闭包函数必须满足两个条件:1.函数内部定义的函数 <strong>2.包含对外部作用域而非全局作用域的引用</strong></li><li>闭包函数的特点：1.自带作用域 2.延迟计算</li></ul><p><em>一般情况下，函数结束，会释放内部变量，但是闭包情况下，如果外部函数结束发现自己有临时变量将来会在内部函数用到，就把这个临时变量绑定给了内部函数，然后自己在结束</em></p></li><li><p><strong>一些例子</strong></p><ul><li>外层函数返回的是一个函数名的话，就返回‘第一层’</li></ul><p><img src="https://i.loli.net/2020/08/26/nfJUcdbuEFA1jW6.png" /></p><ul><li>外层函数返回的是函数调用的话，结果为 第一层 第二层</li></ul><p><img src="https://i.loli.net/2020/08/26/EyLGI6zfUqe38JT.png" /></p><ul><li><p>外部函数定义一个数值变量，形成闭包需要加入nonlocal<img src="https://i.loli.net/2020/08/26/lThZ967xImDbiaQ.png" /></p></li><li><p>其他情况下定义某个对象直接可以传入内部函数，只有再次调用函数f才能输出闭包内函数的结果</p></li></ul></li></ul><p><img src="https://i.loli.net/2020/08/26/rPMxhA56gbQBo2u.png" /></p><h2 id="python装饰器生成器迭代器">14. python装饰器、生成器、迭代器</h2><p><strong>一、装饰器</strong></p><p>函数可以作为参数传递，常用作<strong>插入日志、性能测试、事务处理、缓存和权限校验等场景</strong>。其方式为<strong>外部函数传入被装饰函数名，内部函数返回装饰函数名</strong>。（<em>大白话说感觉就是有一个函数被另一个函数修饰了一下</em>）</p><ul><li><p>应用场景：</p><ul><li><p>日志</p></li><li><p>表单验证</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_validate</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(args[<span class="number">0</span>], str):</span><br><span class="line">            <span class="comment"># isinstance(参数1，参数2),如果1和2类型相同，返回True,否则为False</span></span><br><span class="line">            <span class="keyword">raise</span> BaseException(<span class="string">"first argument need string"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">@pre_validate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate_string</span><span class="params">(string)</span>:</span></span><br><span class="line">    print(string)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">validate_string(<span class="string">'required'</span>)</span><br><span class="line">validate_string(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>特点：</p><ul><li>1.不修改被装饰函数的调用方式<br /></li><li>2.不修改被装饰函数的源代码</li><li>3.为待装饰函数增加额外的功能</li><li>4.返回值为已装饰的函数对象</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种是最简单的，但是fun不能传参，也不能返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(fun)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'开始执行'</span>)</span><br><span class="line">        t1 = time.time()</span><br><span class="line">        fun()</span><br><span class="line">        t2 = time.time()</span><br><span class="line">        print(<span class="string">'打印任务完成，耗费时间为 &#123;:.4&#125;(s)'</span>.format(t2-t1))</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果希望fun能返回一个值, 必须在修饰器里先存储一下，在返回</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(fun)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'开始执行'</span>)</span><br><span class="line">        t1 = time.time()</span><br><span class="line">        result = fun() <span class="comment"># 返回结果为一个随机的元组</span></span><br><span class="line">        t2 = time.time()</span><br><span class="line">        print(<span class="string">'打印任务完成，耗费时间为 &#123;:.4&#125;(s)'</span>.format(t2-t1))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 如果fun能传参数和返回值    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(fun)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'开始执行'</span>)</span><br><span class="line">        t1 = time.time()</span><br><span class="line">        result = fun(*args, **kwargs)</span><br><span class="line">        t2 = time.time()</span><br><span class="line">        print(<span class="string">'\n'</span>)</span><br><span class="line">        print(<span class="string">'打印任务完成，耗费时间为 &#123;:.4&#125;(s)'</span>.format(t2-t1))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@dec</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        print(i, end = <span class="string">' '</span>)</span><br><span class="line">    <span class="keyword">return</span> num+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">n = fun(<span class="number">1000</span>) </span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure><p><strong>二、生成器与迭代器</strong></p><p><img src="https://img-blog.csdn.net/20170516000644044?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamluaXhpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" /></p><blockquote><p>可迭代对象包含迭代器。 如果一个对象拥有__iter__方法，其是可迭代对象；如果一个对象拥有next方法，其是迭代器。 定义可迭代对象，必须实现__iter__方法；定义迭代器，必须实现__iter__和next方法。</p></blockquote><ul><li><strong>迭代器</strong><ul><li>可遍历和迭代的对象</li><li>可以被next()函数调用并不断返回下一个值的对象称为迭代器</li><li>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束；迭代器只能往前不会后退。</li><li>迭代器有两个基本的方法：<strong>iter()和next()</strong> iter返回的是当前对象的迭代器类的实例</li><li>可以使用<strong>isinstance()</strong>判断一个对象是否是迭代器对象(iterator)</li><li>python3中 <strong>range(n)生成的是迭代器对象</strong>；Python2中<strong>xrange(n)生成的才是迭代器对象</strong>？？？</li></ul></li><li><p><strong>生成器</strong></p><ul><li><p>自动实现了迭代器协议，即iter和next方法，<strong>生成器在迭代的过程中可以改变当前迭代值，而修改普通迭代器的当前迭代值往往会发生异常</strong>，影响程序的执行。</p></li><li>生成器的本质就是迭代器。生成器包括两种:<strong>生成器函数和生成器表达式</strong><ul><li><strong>生成器函数：</strong>一个包含yield关键字的函数就是一个生成器函数。并且yield不能和return共用，并且yield只能用在函数内。yield语句一次返回一个结果，在每个结果中间，挂起函数的状态，以便下次重它离开的地方继续执行<ul><li>生成器函数执行之后会得到一个生成器作为返回值，并不会执行函数体。</li><li>执行了__next__()方法之后才会执行函数体，并且获得返回值。</li><li>next()内置方法，内部调用生成器函数的__next__()方法。</li><li>yield和return相同的是可以返回值，但是不同的是<strong>yield 不会结束函数</strong></li></ul></li><li><strong>生成器表达式</strong>：类似于列表推导，但是，生成器返回<strong>按需产生</strong>结果的一个对象，而不是一次构建一个结果列表，按需取出对象。注意生成器用()包裹起来，可以节省内存。</li></ul></li><li><p><strong>生成器作用</strong>：可以实现多任务(协程--&gt;模拟并发)。</p></li></ul></li></ul><blockquote><p>生成器类似于一种数据类型，这种数据类型自动实现了迭代器协议，所以生成器也是迭代器。</p></blockquote><ul><li>生成器实例</li></ul><p><img src="https://i.loli.net/2020/08/26/UcwIlK8XBT6oOLu.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    cur = <span class="number">1</span></span><br><span class="line">    pre = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">yield</span> pre</span><br><span class="line">        pre, cur = cur, cur + pre</span><br><span class="line">g = fib(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><h2 id="python类可以定义哪几种方法静态方法和类应用场景">15. Python类可以定义哪几种方法：静态方法和类应用场景</h2><p><img src="https://i.loli.net/2020/09/05/hEDdqnaArXiIUgF.png" /></p><p>python中实现静态方法和类方法都是依赖于python的装饰器来实现的。 对象方法有self参数，类方法有cls参数，静态方法不需要这些附加参数。</p><ul><li>静态方法</li></ul><p>要在类中使用静态方法，需在类成员函数前面加上@staticmethod标记符，以表示下面的成员函数是静态函数。使用静态方法的好处是，<strong>不需要定义实例即可使用这个方法</strong>。另外，<strong>多个实例共享此静态方法</strong>（静态方法无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，简单讲，静态方法就是放在一个类的作用域里的函数而已）。</p><p>一般用于和类对象以及实例对象无关的代码。不需要传递参数，但是还想归为自己的一类，举例子，创建一个三角形类，一个正方向类，判断能否构成这样的类，在两个类对象中分别加入一个静态方法用于各自的判断</p><ul><li>类方法</li></ul><p>类方法与普通的成员函数和静态函数有不同之处。定义： 一个类方法就可以<strong>通过类或它的实例来调用的方法,</strong> 不管你是用类来调用这个方法还是类实例调用这个方法,<strong>该方法的第一个参数总是定义该方法的类对象。</strong> 也即是方法的第一个参数都是类对象而不是实例对象. 按照习惯，类方法的第一个形参被命名为 <code>cls</code>。任何时候定义类方法都不是必须的（类方法能实现的功能都可以通过定义一个普通函数来实现,只要这个函数接受一个类对象做为参数就可以了）。同时，类方法可以访问类属性，无法访问实例属性。上述的变量grade，在类里是类变量，在实例中又是实例变量，所以使用的时候要注意，使用好的话功能很强大，使用不好容易混淆。</p><p>当一个方法中只涉及到静态属性的时候可以使用类方法(类方法用来修改类属性)</p><h2 id="init__函数init.py的区别">16. __init__函数，<strong>init</strong>.py的区别</h2><p>一个包是一个带有特殊文件 <code>__init__.py</code> 的目录。<code>__init__.py</code> 文件定义了包的属性和方法。其实它可以什么也不定义；可以只是一个空文件，但是必须存在。如果 <code>__init__.py</code> 不存在，这个目录就仅仅是一个目录，而不是一个包，它就不能被导入或者包含其它的模块和嵌套包。</p><p>发现在引入package的过程中，<strong>init</strong>.py会运行，因此，如果某些变量或方法需要常驻内存，可以将它们写入<strong>init</strong>.py文件中。</p><p><strong>init</strong>.py 中还有一个重要的变量，叫做 <strong>all</strong>。我们有时会使出一招“全部导入”，也就是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from PackageName import *</span><br></pre></td></tr></table></figure><h2 id="怎样调用父类方法">17. 怎样调用父类方法</h2><ol type="1"><li>直接写类名调用</li><li>用 super(type, obj).method(arg)方法调用。</li></ol><h2 id="base64">18. Base64</h2><p>简介：Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符（包括a-z、A-Z、0-9、/、+）来表示二进制数据的方法。Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。</p><p>base64 并不是用来加密数据，而是实现在文本协议中传递二进制内容。如 html mime</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">plaintext=<span class="string">"aaa"</span> <span class="comment"># 明文为aaa</span></span><br><span class="line">s=base64.b64encode(plaintext.encode()) <span class="comment"># 这里的s是字节码,编码的过程中,参数只能是字节码</span></span><br><span class="line">print(s)</span><br><span class="line">t=base64.b64decode(s) <span class="comment"># 这里t的类型是字节码,这也是python的缺点,许多数据类型不明确.解码的过程中参数可以是字符串也可以是字节码</span></span><br><span class="line">print(t) <span class="comment"># t是s解码后的字节码</span></span><br><span class="line">print(t.decode()) <span class="comment"># 输出的是plaintext</span></span><br></pre></td></tr></table></figure><h2 id="python的反射机制">19. python的反射机制</h2><p><strong>反射</strong>就是通过字符串的形式，导入模块；通过字符串的形式，去模块寻找指定函数，并执行。利用字符串的形式去对象（模块）中操作（查找/获取/删除/添加）成员，<strong>一种基于字符串的事件驱动！</strong></p><p>https://www.cnblogs.com/Guido-admirers/p/6206212.html</p><h2 id="什么是pythonpath">20. 什么是PYTHONPATH？</h2><p>Pythonpath是导入模块时使用的环境变量。每当导入模块时，也会查找PYTHONPATH以检查各个目录中是否存在导入的模块。解释器使用它来确定要加载的模块。</p><p>PYTHONPATH是Python中一个重要的环境变量,用于在导入模块的时候搜索路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</span><br><span class="line">[<span class="string">''</span>, <span class="string">'/usr/lib/python2.7'</span>, <span class="string">'/usr/lib/python2.7/plat-x86_64-linux-gnu'</span>,</span><br><span class="line"> <span class="string">'/usr/lib/python2.7/lib-tk'</span>, <span class="string">'/usr/lib/python2.7/lib-old'</span>, </span><br><span class="line"><span class="string">'/usr/lib/python2.7/lib-dynload'</span>, <span class="string">'/usr/local/lib/python2.7/dist-packages'</span>,</span><br><span class="line"> <span class="string">'/usr/lib/python2.7/dist-packages'</span>, <span class="string">'/usr/lib/python2.7/dist-packages/PILcompat'</span>, </span><br><span class="line"><span class="string">'/usr/lib/python2.7/dist-packages/gtk-2.0'</span>, <span class="string">'/usr/lib/pymodules/python2.7'</span>,</span><br><span class="line"> <span class="string">'/usr/lib/python2.7/dist-packages/ubuntu-sso-client'</span>]</span><br></pre></td></tr></table></figure><p>可以看到,路径列表的第一个元素为空字符串,<strong>代表的是相对路径下的当前目录.</strong></p><p>由于在导入模块的时候,解释器会按照列表的顺序搜索,直到找到第一个模块,所以优先导入的模块为同一目录下的模块.</p><p>导入模块时搜索路径的顺序也可以改变.这里分两种情况:</p><p>1,通过sys.path.append(),sys.path.insert()等方法来改变,这种方法当重新启动解释器的时候,原来的设置会失效.</p><p>2,改变PYTHONPATH,这种设置方法永久有效:</p><p>在这种情况下,可以通过在sys.path列表显示的路径中<a href="https://docs.python.org/3/install/index.html#modifying-python-s-search-path" target="_blank" rel="noopener">添加.pth文件</a>来实现</p><hr /><p>今日分享结束～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;秋招以来，为了找工作又学习了很多python相关的知识，给大家分享一下，里面好多内容都是我东拼西凑出来的（如果是借鉴了其他博客的，希望大家可以指出，我会标注上），感觉都是比较常见的或者被问到的。&lt;/p&gt;
&lt;p&gt;希望这篇分享会对大家找工作有所帮助～&lt;/p&gt;
    
    </summary>
    
    
      <category term="python知识点" scheme="http://zymdragonggg.github.io/categories/python%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="python" scheme="http://zymdragonggg.github.io/tags/python/"/>
    
      <category term="面试" scheme="http://zymdragonggg.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>python面试知识点总结（一）</title>
    <link href="http://zymdragonggg.github.io/2020/10/07/python%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://zymdragonggg.github.io/2020/10/07/python%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-10-07T13:53:16.000Z</published>
    <updated>2020-10-07T14:28:05.584Z</updated>
    
    <content type="html"><![CDATA[<p>秋招以来，为了找工作又学习了很多python相关的知识，给大家分享一下，里面好多内容都是我东拼西凑出来的（如果是借鉴了其他博客的，希望大家可以指出，我会标注上），感觉都是比较常见的或者被问到的。</p><p>希望这篇分享会对大家找工作有所帮助～</p><a id="more"></a><h2 id="python语言特性">1. python语言特性</h2><p><strong>Python是一种解释型语言</strong>。与C语言等语言不同，Python不需要在运行之前进行编译。</p><p><strong>Python是动态语言</strong>，当声明变量或类似变量时，不需要声明变量的类型。编写Python代码很快，但运行比较慢。</p><ul><li>静态语言是在<strong>编译时</strong>变量的数据类型即可确定的语言</li><li>动态语言是在<strong>运行时</strong>确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。</li></ul><blockquote><p>我们平时写的代码，需要编译，计算机才能执行。</p><p>解释执行（动态编译）：解释一句，执行一句。启动速度更快、内存占用少，但是效率低，非独立</p><p>编译执行（静态编译）：只需要编译一次，可以多次运行。执行效率高。对于大型项目通常采用编译执行的语言。</p></blockquote><h2 id="基本的数据结构">2. 基本的数据结构</h2><p><strong>不可变数据类型：</strong>数值型（number：int, float,bool,complex）、字符串型string、元组tuple</p><p><strong>可变数据类型：</strong>列表和字典</p><ul><li><p>序列结构：</p><ul><li><strong>list</strong>：列表是一种序列，可以看做是一种数组，但不同的于其它语言的是，Python列表中的元素可以是任何数据类型，诸如，数字、字符串等等。<ul><li><strong>是基于数组或者链表实现的，所以有序</strong>。</li><li>list中的元素就是指针。是长度可变的数组，每次都会分配略大的内存防止频繁的申请分配内存，连续的一块的内存。</li></ul></li><li><strong>tuple</strong>：元组和列表一样，都以看做是一种数组，元素可以是任何数据类型，甚至可以嵌套。同样元组可切片，切片方法同list，但是元组使用小括号创建。<ul><li>相对于 list 而言，tuple 是不可变的，元组内的元素一旦创建，是不可修改的，也不可追加，这使得它可以作为 dict 的 key，或者扔进 set 里，而 list 则不行。但可以用切片的方式更新元组。</li><li>tuple 放弃了对元素的增删（内存结构设计上变的更精简），换取的是性能上的提升：创建 tuple 比 list 要快，存储空间比 list 占用更小。所以就出现了“能用 tuple 的地方就不用 list”的说法。</li><li>多线程并发的时候，tuple 是不需要加锁的，不用担心安全问题，编写也简单多了</li><li>如果要创建的元组中只有一个元素，要在它的后面加上一个逗号‘，’，元组里只有一个元素的时候，逗号（，）非常重要。</li></ul></li></ul></li><li><p>散列结构</p><p>散列结构中，元素顺序是不重要的，顺序不同的散列，还是同一个散列。散列结构有set、dict。</p><ul><li><p><strong>set</strong>，集合，集合是由不重复元素组成的无序的集，重点是不重复，和数学中的集合类似。无序是散列结构的特点，集合是一种散列结构，所以集合也有无序的特点。<strong>set是hash实现的，所以是无序的</strong></p></li><li><strong>dict，</strong>字典，字典由键值对组成，具有唯一性，可变性。<strong>字典是通过散列表或说哈希表实现的</strong>。<ul><li>字典是可变对象但字典<strong>的键的唯一的</strong>，是不可变对象，因为要确保经过Hash算法以后得到的地址唯一。</li><li>字典遍历时，时间复杂度取决于字典拥有的最大键值对的数量，即使key被remove，但是依旧保持这个hash,首先链地址法是可以直接删除元素的，但是开放定址法是不行的，正确做法应该是删除之后置入一个原来不存在的数据，比如-1</li><li>字典的三个基本操作（添加元素、获取元素、删除元素）的平均时间复杂度为O（1）</li><li>字典用链地址法解决冲突</li><li>理解字典的最好方式，就是将它看做是一个 键 : 值对的集合。<strong>字典的无序是指数据存进字典的顺序跟取出字典的顺序不一致</strong>python3.6之前是无序的，是有序的。</li></ul></li></ul></li></ul><h2 id="python中的赋值复制浅拷贝与深拷贝">3. Python中的赋值(复制)、浅拷贝与深拷贝</h2><ul><li>复制不可变数据类型，不管如何，都是同一个地址</li></ul><p><img src="https://i.loli.net/2020/08/26/NqIUkzDW67wrg1V.png" /></p><ul><li>复制可变数据类型<ul><li>赋值: 只是复制了新对象的引用，不会开辟新的内存空间。</li><li>浅拷贝: 创建新对象，其内容是原对象的引用。浅拷贝之所以称为浅拷贝，是它仅仅只拷贝了一层，拷贝了最外围的对象本身<ul><li>当浅复制的值是不可变对象（字符串、元组、数值类型）时和“赋值”的情况一样，对象的id值<em>（id()函数用于获取对象的内存地址）</em>与浅复制原来的值相同。</li><li>当浅复制的值是可变对象（列表、字典、集合）时会产生一个“不是那么独立的对象”存在。有两种情况：<ul><li>第一种情况：复制的对象中无复杂子对象，原来值的改变并不会影响浅复制的值，同时浅复制的值改变也并不会影响原来的值。原来值的id值与浅复制原来的值不同。</li><li>第二种情况：复制的对象中有复杂子对象（例如列表中的一个子元素是一个列表），如果不改变其中复杂子对象，浅复制的值改变并不会影响原来的值。 但是改变原来的值中的复杂子对象的值会影响浅复制的值。</li></ul></li></ul></li><li>深拷贝：和浅拷贝对应，深拷贝拷贝了对象的所有元素，包括多层嵌套的元素。深拷贝出来的对象是一个全新的对象，不再与原来的对象有任何关联。</li></ul></li></ul><h2 id="funargskwargs中的argskwargs什么意思">4. <code>fun(*args,**kwargs)</code>中的<code>*args</code>,<code>**kwargs</code>什么意思？</h2><p>可以将不定数量的参数传递给一个函数。</p><p><code>*args</code>用来发送一个<strong>非键值对的可变数量的参数列表</strong>给一个函数（元组的方式传参）</p><p><code>**kwargs</code>用来发送一个<strong>键值对的可变参数量的参数列表</strong>给一个函数（字典的方式传参）</p><p><img src="https://i.loli.net/2020/09/03/6Pb9frRHZ72uaIg.png" /></p><h2 id="python中什么元素为假">5. python中什么元素为假</h2><p>0，空字符串，空列表，空字典。空元组，none, False</p><h2 id="python传参数是传值还是传址">6. python传参数是传值还是传址</h2><p>python中函数参数的引用传递（不是传值）。对于不可变类型，传入函数中，不会影响到变量自身。对于不可变类型，会更改变量自身。</p><h2 id="单引号和双引号区别">7. 单引号和双引号区别</h2><p><img src="https://i.loli.net/2020/09/03/osvMhfBlIJ2GOFn.png" /></p><h2 id="关于python中的复数">8. 关于python中的复数</h2><ul><li>复数的语法：real+image j</li><li>实部和虚部都是浮点数</li><li>虚部的后缀可以是j也可以是J</li><li>复数的conjugate方法可以返回该复数的共轭复数</li></ul><h2 id="python逻辑运算符">9. python逻辑运算符</h2><ul><li><p>and,同真取最后一个真，有假取假</p><p><img src="https://i.loli.net/2020/09/03/SVkRixrIvtTlUdw.png" /></p></li><li><p>or,只要第一个不是假就取第一个的值，否则一律取第二个数的值</p><p><img src="https://i.loli.net/2020/09/03/wJIlfgKmuzxrvGd.png" /></p></li><li><p>not 取反，返回True或者False</p></li></ul><h2 id="python比较运算符">10. python比较运算符</h2><ul><li><p><strong>比较运算符优先级大于逻辑运算符</strong></p></li><li><p>比较两个字符时，是比较ASCII码</p></li><li><p>python不支持复数比较大小，抛出TypeError错误</p></li><li><p>python支持连续比较：<code>3&gt;2&gt;2</code>等价于<code>3&gt;2and2&gt;2</code>，返回结果为False</p></li><li><p>python3不支持数字和字符串比较，报错为TypeError。python2支持，如<code>(2,3)&lt;('a','b')</code>，从第一个元素的ASCII码开始比较，直到两个元素不相等为止，如果前面都相等，那么元素个数多的tuple较大</p></li><li><p>字符串比较也是从第一个字符的ASCII码开始比较，直到两个字符不相等为止</p><p><em>字母和数字的ASCII码范围：'a<sub>z'&gt;'A</sub>Z'&gt;'0~9'</em>(61-7A)&gt;(41-5A)&gt;（30-39）</p></li></ul><h2 id="python中的return">11. python中的return</h2><ul><li>return可以有多个返回值</li><li>没有返回值时，函数自动返回<strong>None</strong></li><li>执行到return时，程序将停止函数return后面的语句</li></ul><h2 id="python中的重载和重写">12. python中的重载和重写</h2><p><strong>重载</strong>：在一个类里，方法的名字相同参数不同，返回类型可以相同也可以不同；重载是让类以统一的方式处理不同类型数据的一种手段。</p><p><strong>函数重载想要解决的问题：</strong>可变参数类型、可变参数个数。</p><p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。</p><p>在python中， 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。除此之外，python对那些缺少的参数设定为缺省参数。故python 不需要函数重载。</p><p><strong>重写：</strong>子类不想原封不动地继承父类的方法，而是想做一定的修改，就需要用到方法的重写，又称为方法的覆盖</p><h2 id="python模块导入">13. python模块导入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xxx <span class="keyword">import</span> yyy</span><br><span class="line"><span class="keyword">import</span> xxx</span><br><span class="line"><span class="keyword">from</span> xxx <span class="keyword">import</span> * <span class="comment">#此时也是把模块中的所有内容导入</span></span><br><span class="line"><span class="keyword">import</span> xxx, zzz</span><br><span class="line"><span class="keyword">from</span> xxx <span class="keyword">import</span> yyy,mmm</span><br><span class="line"><span class="keyword">import</span> xxx <span class="keyword">as</span> AAA</span><br></pre></td></tr></table></figure><h2 id="python中的栈和队列">14. python中的栈和队列</h2><p>都可以直接用列表来实现</p><ul><li><p>栈：stack = []</p><ul><li>入栈：stack.append()</li><li>出栈：stack.pop()</li></ul></li><li><p>队列：queue = []</p><ul><li><p>入队：queue.append()</p></li><li><p>出队：queue.pop(0)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">q = deque()</span><br><span class="line">q.append(<span class="string">'eat'</span>)</span><br><span class="line">q.popleft()</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="python-is-和-区别">15. python is 和 == 区别</h2><p>==用来比较判断两个对象的value(值)是否相等</p><p>is比较判断的是对象间的唯一身份标识，也就是id是否相同</p><p><strong>总的来说，只有数值型和字符串型，并且在通用对象池中的情况下，a is b才为True，否则当a和b是int，str，tuple，list，dict或set型时，a is b均为False。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">print(a <span class="keyword">is</span> <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>输出为False</p><h2 id="列出5个python标准库">16. 列出5个Python标准库</h2><blockquote><p>这里我就随便找了几个，大家可以自己多了解一下</p></blockquote><ul><li>os: 提供与操作系统相关联的函数，这个库就是对操作系统的封装。os.path 是文件路径相关的操作，对于 Linux，Windows 不同的操作系统下不同的文件路径表示方法提供统一的接口。其他的还有文件夹的创建删除，文件权限的修改，执行命令等等，在不同的操作系统下是不同的操作，<strong>但是 os 库提供来统一的接口，这样就容易编写操作系统无关的程序了，易于移植</strong>。</li><li>sys:通常用于命令行参数。sys模块主要是针对与Python解释器相关的变量和方法，不是主机操作系统。获取python解释器的版本信息：<code>sys.version</code>，获取操作系统平台：<code>sys.platform</code>获取命令行参数，获取模块的查找路径<code>sys.path</code></li><li>re: 正则匹配</li><li>math： 数学运算 math.sqrt</li><li>datetime：处理日期时间<code>a = datetime.date.today()</code></li></ul><h2 id="python怎么删除数组中的元素">17. python怎么删除数组中的元素</h2><ul><li><p>del：根据索引值删除元素</p><ul><li><p>del 是 Python 中的关键字，专门用来执行删除操作，它不仅可以删除整个列表，还可以删除列表中的某些元素。</p></li><li><p>del 可以删除列表中的单个元素，格式为：<code>del listname[index]</code></p></li><li><p>del 也可以删除中间一段连续的元素，格式为：<code>del listname[start : end]</code></p><p><em>其中，start 表示起始索引，end 表示结束索引。del 会删除从索引 start 到 end 之间的元素，不包括 end 位置的元素。</em></p></li></ul></li><li><p>pop()：根据索引值删除元素</p><ul><li><p>pop() 方法用来删除列表中指定索引处的元素，具体格式如下：<code>listname.pop(index)</code></p><p><em>大部分编程语言都会提供和 pop() 相对应的方法，就是 push()，该方法用来将元素添加到列表的尾部，类似于数据结构中的“入栈”操作。但是 Python 是个例外，Python 并没有提供 push() 方法，因为完全可以使用 append() 来代替 push() 的功能。</em></p></li></ul></li><li><p>remove()：根据元素值进行删除</p><ul><li>该方法会根据元素本身的值来进行删除操作。</li><li>需要注意的是，<strong>remove() 方法只会删除第一个和指定值相同的元素，</strong>而且必须保证该元素是存在的，否则会引发 ValueError 错误。</li><li>remove() 方法使用示例：</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">40</span>, <span class="number">36</span>, <span class="number">89</span>, <span class="number">2</span>, <span class="number">36</span>, <span class="number">100</span>, <span class="number">7</span>]<span class="comment">#第一次删除36</span></span><br><span class="line">nums.remove(<span class="number">36</span>)</span><br><span class="line">print(nums)<span class="comment">#第二次删除36</span></span><br><span class="line">nums.remove(<span class="number">36</span>)</span><br><span class="line">print(nums)<span class="comment">#删除78</span></span><br><span class="line">nums.remove(<span class="number">78</span>)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>[40, 89, 2, 36, 100, 7] [40, 89, 2, 100, 7] Traceback (most recent call last): File &quot;C:.py&quot;, line 9, in <module> nums.remove(78) ValueError: list.remove(x): x not in list</p><p>最后一次删除，因为 78 不存在导致报错，所以我们在使用 remove() 删除元素时最好提前判断一下。</p><ul><li>clear()：删除列表所有元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = list(<span class="string">"http://c.biancheng.net/python/"</span>)</span><br><span class="line">url.clear()</span><br><span class="line">print(url)</span><br></pre></td></tr></table></figure><h2 id="python字典操作">18. python字典操作</h2><p>items()、keys()、values() 分别用于获取字典中的所有 key-value 对、所有 key、所有 value。这三个方法依次返回 dict_items、dict_keys 和 dict_values 对象，Python 不希望用户直接操作这几个方法，但可通过 list() 函数把它们转换成列表。</p><p>（1）字典如何删除键和合并两个字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">'name'</span>:<span class="string">'zym'</span>,<span class="string">'age'</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">del</span> dic[<span class="string">'name'</span>]</span><br><span class="line">dic2 = &#123;<span class="string">'name'</span>:<span class="string">'ls'</span>&#125;</span><br><span class="line">dic.update(dic2)</span><br></pre></td></tr></table></figure><p>（2）字典根据键从小到大排序</p><p><code>sorted(dict.items(),key=lambda i:i[0],reverse = False)</code></p><h2 id="python的位运算">19. Python的位运算</h2><table><thead><tr class="header"><th>符号</th><th>描述</th><th>运算规则 by MoreWindows</th></tr></thead><tbody><tr class="odd"><td>&amp;</td><td>与</td><td>两个位都为1时，结果才为1 （统计奇数）</td></tr><tr class="even"><td>|</td><td>或</td><td>两个位都为0时，结果才为0 （统计偶数）</td></tr><tr class="odd"><td>^</td><td>异或</td><td>两个位相同为0，相异为1 (常用统计不相同数）</td></tr><tr class="even"><td>~</td><td>取反</td><td>0变1，1变0</td></tr><tr class="odd"><td>&lt;&lt;</td><td>左移</td><td>各二进位全部左移若干位，高位丢弃，低位补0</td></tr><tr class="even"><td>&gt;&gt;</td><td>右移</td><td>各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）</td></tr></tbody></table><hr /><p>好啦，今日分享到此，后续会继续更新有关知识点的总结～：）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;秋招以来，为了找工作又学习了很多python相关的知识，给大家分享一下，里面好多内容都是我东拼西凑出来的（如果是借鉴了其他博客的，希望大家可以指出，我会标注上），感觉都是比较常见的或者被问到的。&lt;/p&gt;
&lt;p&gt;希望这篇分享会对大家找工作有所帮助～&lt;/p&gt;
    
    </summary>
    
    
      <category term="python知识点" scheme="http://zymdragonggg.github.io/categories/python%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="python" scheme="http://zymdragonggg.github.io/tags/python/"/>
    
      <category term="面试" scheme="http://zymdragonggg.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>python3中的基本数据类型和数据结构</title>
    <link href="http://zymdragonggg.github.io/2020/07/23/python%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%89%B9%E6%80%A7/"/>
    <id>http://zymdragonggg.github.io/2020/07/23/python%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%89%B9%E6%80%A7/</id>
    <published>2020-07-23T13:55:20.000Z</published>
    <updated>2020-07-23T14:21:14.363Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了python3的基本数据类型以及基本数据结构，详细介绍了几种基本数据结构的特性以及他们的区别，还涉及了一些不同版本python之间的差别。</p><a id="more"></a><h1 id="一python3中的基本数据类型">一、python3中的基本数据类型</h1><p><strong>不可变数据类型</strong>：Number（数字）、String（字符串）、Tuple（元组）</p><p><strong>可变数据类型</strong>：List（列表）、Dictionary（字典）、Set（集合）</p><h1 id="二python3中的基本数据结构">二、python3中的基本数据结构</h1><p>基本数据结构可以分为<strong>序列结构和散列结构</strong>。</p><ul><li><p><strong>序列结构</strong></p><ul><li><p><strong>list</strong>：列表可以看做是一种数组，Python列表中的元素可以是任何数据类型，如，数字、字符串等等。其实现是利用链表实现的，所以列表是有序的。</p></li><li><p><strong>tuple</strong>：元组和列表一样，唯一的区别是，元组内的元素一旦创建，是不可修改的，也不可追加。并且元组使用小括号创建。同样的元组也是有序的。</p></li></ul></li><li><p><strong>散列结构</strong></p><p><em>散列结构中，元素顺序是不重要的，顺序不同的散列，还是同一个散列。散列结构有set、dict。</em></p><ul><li><p><strong>set</strong>：集合是由不重复元素组成的无序的集。其实现是利用hash表实现的，所以集合是无序的。</p></li><li><p><strong>dict</strong>：字典由键值对组成，字典是可变对象但字典的键的唯一的，是不可变对象。</p><p>需要注意的是：python3.6版本以前的字典都是无序的，如果想要实现有序字典需要利用OrderDict()。而3.6版本以后，对字典进行了改进，所以保证了有序。</p><p>字典的无序：数据存进字典的顺序跟取出的字典的顺序不一致。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">d1=&#123;&#125;</span><br><span class="line">d1=collections.OrderedDict()  <span class="comment">#将普通字典转换为有序字典</span></span><br><span class="line">d1[<span class="string">'a'</span>]=<span class="string">'A'</span></span><br><span class="line">d1[<span class="string">'b'</span>]=<span class="string">'B'</span></span><br><span class="line">d1[<span class="string">'c'</span>]=<span class="string">'C'</span></span><br><span class="line">d1[<span class="string">'d'</span>]=<span class="string">'D'</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> d1.items():</span><br><span class="line">    <span class="keyword">print</span> k,v</span><br></pre></td></tr></table></figure></li></ul><hr /><p>之前使用python都是不会了就查，所以基础太薄弱了，故开始学习python的相关基础知识，希望巩固自己的基础知识，也可以帮助大家！：）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了python3的基本数据类型以及基本数据结构，详细介绍了几种基本数据结构的特性以及他们的区别，还涉及了一些不同版本python之间的差别。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python知识点" scheme="http://zymdragonggg.github.io/categories/python%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="python3" scheme="http://zymdragonggg.github.io/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>为VScode中LaTex配置单词语法检查</title>
    <link href="http://zymdragonggg.github.io/2020/06/14/%E4%B8%BAVScode%E4%B8%ADLaTex%E9%85%8D%E7%BD%AE%E5%8D%95%E8%AF%8D%E8%AF%AD%E6%B3%95%E6%A3%80%E6%9F%A5/"/>
    <id>http://zymdragonggg.github.io/2020/06/14/%E4%B8%BAVScode%E4%B8%ADLaTex%E9%85%8D%E7%BD%AE%E5%8D%95%E8%AF%8D%E8%AF%AD%E6%B3%95%E6%A3%80%E6%9F%A5/</id>
    <published>2020-06-14T15:03:17.000Z</published>
    <updated>2020-06-14T15:11:39.687Z</updated>
    
    <content type="html"><![CDATA[<p>本文提供如何利用VScode的拓展包实现对拼写错误的检查的功能。</p><a id="more"></a><p>以前用LaTex写论文用WinEdt软件，这是Windows平台下可用于编辑LaTex的一个编辑器，能够自动检查拼写错误，在Mac上，我用了VScode作为编辑器写LaxTex，但是并不对拼写错误进行检查。下面介绍如何在VScode上检查语法错误。</p><hr /><h1 id="直接安装插件"><strong>直接安装插件</strong></h1><ul><li>打开Extensions，输入搜索LTeX</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfrzn3io3cj30k303vgm7.jpg" /></p><ul><li>安装插件<ul><li>它会自动下载安装一个ltex-Is的依赖包。</li></ul></li></ul><blockquote><p>当用LTex检查Latex文档时，会将其传给ltex-Is，ltex-Is是用Java编写的，对文档进行解析后传递给LanguageTool，这之后实际进行检查的就是这个LanguageTool了。不LanguageTool不用额外的下载安装了，看介绍似乎是说已经在LTex新版中加入进来了。</p></blockquote><h1 id="可能存在的问题"><strong>可能存在的问题</strong></h1><p>有时候可能是网络原因，可能需要翻墙，所以下载ltex-Is会很慢，可以采取<a href="https://github.com/valentjn/vscode-ltex/releases" target="_blank" rel="noopener">offline安装</a>，</p><ul><li>进入到上述链接，根据自己的系统版本下载相应的ltex-Is安装包。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfrzwwlyx5j30mi07aaax.jpg" /></p><ul><li>安装ltex-ls<ul><li>点击设置中的command Palette。</li><li><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfrzxx95jaj307p08itbi.jpg" /></li><li>通过命令：<code>Extensions: Install from VSIX...</code>安装下载下来的包。</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfs009tod6j30gg01mmxa.jpg" /></p><p>至此就可以了。</p><p>看看效果：</p><p>比如提示transmit可能有错误，他会给出修改建议，语法也能修改。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfs026wnvhj30hl04nt9t.jpg" /></p><p>如果单纯想看看怎么改这个词，看不到提示，可以选中那个单词，这时旁边就会出现一个小灯泡，点击小灯泡就给出修改意见了，如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfs08knhc4j306g05tjt7.jpg" /></p><p>Nice,非常好用！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文提供如何利用VScode的拓展包实现对拼写错误的检查的功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tips" scheme="http://zymdragonggg.github.io/categories/Tips/"/>
    
    
      <category term="LaTex" scheme="http://zymdragonggg.github.io/tags/LaTex/"/>
    
      <category term="VScode" scheme="http://zymdragonggg.github.io/tags/VScode/"/>
    
  </entry>
  
  <entry>
    <title>网络爬虫入门实践项目</title>
    <link href="http://zymdragonggg.github.io/2020/06/12/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"/>
    <id>http://zymdragonggg.github.io/2020/06/12/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/</id>
    <published>2020-06-12T13:26:59.000Z</published>
    <updated>2020-06-12T13:42:13.306Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍一些入门的实践项目，非常简单的几个例子。</p><a id="more"></a><p>继上之前有关<a href="https://zymdragonggg.github.io/2020/05/22/爬虫入门学习-安装以及Requests库介绍/">爬虫基础及Requests库介绍</a>以及<a href="https://zymdragonggg.github.io/2020/05/25/网络爬虫的问题和行为规范/">网络爬虫的问题和行为规范</a>介绍后，今天开始进行三个实践小项目。</p><h1 id="实例1京东商品页面爬取">实例1:京东商品页面爬取</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url, hd)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, headers = hd)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text[:<span class="number">1000</span>] <span class="comment">#不要显示太多，只显示前1000个字符</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"产生异常"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    url = <span class="string">"https://item.jd.com/4406761.html"</span> <span class="comment">#magic keyboard2</span></span><br><span class="line">    hd = &#123;<span class="string">'user-agent'</span>:<span class="string">'Mozilla/5.0'</span>&#125; <span class="comment"># 注意这里需要加入user-agent，要不然返回的信息似乎是要登陆。</span></span><br><span class="line">    print(getHTMLText(url, hd))</span><br></pre></td></tr></table></figure><p>注意，如果不指定headers字段，那么是爬不到结果的，这是因为当我们直接用requests库爬取时，会告知网页我们使用的是requests库，利用<code>r.requests.headers</code>可以看到<code>user-agent</code>字段的内容是<code>'python-requests/版本号'</code>。</p><p>由于有些网站不允许爬虫，于是对其进行了限制。不过为了爬取，我们可以采取指定<code>user-agent</code>字段为一个伪装的浏览器。这就是上面hd那一行代码的由来。这样我们爬取的时候网页会以为我们是一个浏览器访问的。</p><h1 id="实例2-搜索引擎关键词提交">实例2: 搜索引擎关键词提交</h1><p>百度的关键词接口：</p><p><code>http://www.baidu.com/s?wd=keyword</code></p><p>360的关键词接口：</p><p><code>http://www.so.com/s?q=keyword</code></p><p>只要构造这样的url就可以完成关键字提交。可以利用params可以向url中增加内容。下面以360搜索为例（百度搜索根据现有知识无法做到爬取网页，必须要验证，360目前还ok）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url, hd, kv)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, headers = hd, params = kv)</span><br><span class="line">        print(r.request.url) <span class="comment"># 可以利用这个语句获取当前requests的url是什么</span></span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        print(len(r.text))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">'爬取异常'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    hd = &#123;<span class="string">'user-agent'</span>:<span class="string">'Mozilla/5.0'</span>&#125;</span><br><span class="line">    kv = &#123;<span class="string">'q'</span>:<span class="string">'Python'</span>&#125; <span class="comment"># 给出搜索词</span></span><br><span class="line">    url = <span class="string">'https://www.so.com/s'</span></span><br><span class="line">    getHTMLText(url, hd, kv)</span><br></pre></td></tr></table></figure><p>返回的输出结果为：</p><p><code>&gt;&gt;&gt; https://www.so.com/s?q=Python</code></p><p><code>&gt;&gt;&gt; 319088</code></p><h1 id="实例3-网络图片的爬取">实例3: 网络图片的爬取</h1><p>爬取的图片来自中国国家地理网站。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    url = <span class="string">'http://img0.dili360.com/ga/M00/48/CB/wKgBzFmeOaWAAg7SAAMP0b_hOVw041.tub.jpg'</span></span><br><span class="line">    root = <span class="string">'./'</span></span><br><span class="line">    path = root + url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]    <span class="comment"># 获得网页中图片的名字，即.jpg前面的内容</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(root):    <span class="comment"># 如果根目录不存在，就创建一个</span></span><br><span class="line">            os.mkdir(root)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):    <span class="comment"># 如果路径不存在，就读取</span></span><br><span class="line">            r = requests.get(url)</span><br><span class="line">            <span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> f: <span class="comment"># 读入到路径中</span></span><br><span class="line">                f.write(r.content)</span><br><span class="line">                f.close()</span><br><span class="line">                print(<span class="string">'文件保存成功'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'文件已存在'</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">'读取失败'</span>)</span><br></pre></td></tr></table></figure><p>经过三个小实例的学习，其实爬虫主要就是解析网站，然后爬取相应的内容。</p><p>感谢北京理工大学老师的课程，虽然课程可能有些旧，好多网页根据课程教的已经不好爬到东西了，但是感觉真的是很清晰明了了。</p><hr /><p>接下来似乎就可以进阶了，希望自己能在7月到来前把基础学个差不多，最近感觉有点心急，想学的东西太多，心急吃不了热豆腐，慢慢积累不断丰富自己吧。</p><p>加油：）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍一些入门的实践项目，非常简单的几个例子。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络爬虫" scheme="http://zymdragonggg.github.io/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="网络爬虫" scheme="http://zymdragonggg.github.io/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>网络爬虫的问题和行为规范</title>
    <link href="http://zymdragonggg.github.io/2020/05/25/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A1%8C%E4%B8%BA%E8%A7%84%E8%8C%83/"/>
    <id>http://zymdragonggg.github.io/2020/05/25/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A1%8C%E4%B8%BA%E8%A7%84%E8%8C%83/</id>
    <published>2020-05-25T04:28:32.000Z</published>
    <updated>2020-05-25T04:38:48.701Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单介绍了网络爬虫的类型、存在的问题、限制形式以及Robots协议内容。</p><a id="more"></a><p>继上一篇有关<a href="https://zymdragonggg.github.io/2020/05/22/爬虫入门学习-安装以及Requests库介绍/">爬虫基础及Requests库介绍</a>后，继续学习廖雪峰老师的课，感觉讲的非常系统。继续做笔记～</p><h1 id="一.-网络爬虫类型">一. 网络爬虫类型</h1><ol type="1"><li><p>目的：爬取网页，玩转网页</p><p>特征：小规模，数据量小爬取速度不敏感</p><p>方法：Requests库</p></li><li><p>目的：爬取网站，爬取系列网站</p><p>特征：中规模，数据规模较大，爬取速度敏感</p><p>方法：Scrapy库</p></li><li><p>目的：爬取全网</p><p>特征：大规模，搜索引擎，爬取速度关键</p><p>方法：定制开发</p></li></ol><h1 id="二.-爬虫引发的问题">二. 爬虫引发的问题</h1><p>网络爬虫带来便利的同时也造成了很多风险：</p><ol type="1"><li>超出服务器服务能力，对服务器性能造成“骚扰”</li><li>内容法律风险</li><li>个人隐私泄露</li></ol><p>由于存在种种问题，这就需要网站都对爬虫进行限制。</p><h1 id="三.-爬虫的限制">三. 爬虫的限制</h1><p>限制方法有以下两种：</p><ul><li>来源审查：判断user-agent进行限制<ul><li>检查来访HTTP协议头的User-Agent，只响应浏览器或友好爬虫访问。</li></ul></li><li>发布公告：Robots协议<ul><li>告知爬取策略，要求爬虫遵守。</li></ul></li></ul><h1 id="四.-robots协议">四. Robots协议</h1><h2 id="robots协议基本概念">1. Robots协议基本概念</h2><p>Robots Exclusion Standard 网络爬虫排除标准</p><p>作用：网站告知爬虫哪些页面可以抓取，哪些不可以。</p><p>形式：在网站根目录下的<code>robots.txt</code>文件。</p><p>Robots协议基本语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: &#x2F;</span><br></pre></td></tr></table></figure><p>案例：京东 https://www.jd.com/robots.txt</p><p>第一个红框代表：任何访问形式都需要遵守以下协议。</p><p>第二个红框代表：以下几种爬虫不能访问任何资源。</p><figure><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4jiedvomj307e07dwex.jpg" alt="image-20200525113453620" /><figcaption>image-20200525113453620</figcaption></figure><p>如果没有<code>robots.txt</code>文件，那么说明可以任意爬取。</p><h2 id="遵守方式">2. 遵守方式</h2><p>网络爬虫：自动或人工识别robots.txt协议，在进行内容爬取。</p><p>约束性：Robots协议是建议但是非约束性的，网络爬虫可以不遵守，但是存在法律风险。</p><p>Tips：类人类行为可不参考Robots协议，简单就是说访问量很小。（我寻思这就是打造一个可以慢吞吞但类人的爬虫哦！）</p><hr /><p>这次的笔记内容比较轻松好理解，学起来很快，突然对爬虫产生了浓厚的兴趣。不过似乎现在很多反爬虫什么的。相信随着科技的发展，很多东西在给我们带来便利的同时，也会被逐渐限制。或许等某一天我再看自己写的这个博客，Robots协议变得更加有限制性吧。</p><p>じゃね〜</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单介绍了网络爬虫的类型、存在的问题、限制形式以及Robots协议内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络爬虫" scheme="http://zymdragonggg.github.io/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="网络爬虫" scheme="http://zymdragonggg.github.io/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
      <category term="Robots协议" scheme="http://zymdragonggg.github.io/tags/Robots%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>爬虫入门学习-安装以及Requests库介绍</title>
    <link href="http://zymdragonggg.github.io/2020/05/22/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8ARequests%E5%BA%93%E4%BB%8B%E7%BB%8D/"/>
    <id>http://zymdragonggg.github.io/2020/05/22/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8ARequests%E5%BA%93%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-05-22T11:06:23.000Z</published>
    <updated>2020-05-22T11:13:56.074Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是为了记录网络爬虫学习过程中的笔记和自己的一丢丢理解，希望可以通过本文以及如果有后续文章的话，能够掌握网络数据爬虫和网页解析的基本能力。</p><a id="more"></a><p>本文主要是参考了<a href="https://www.bilibili.com/video/BV1kx411S7Fh?p=7" target="_blank" rel="noopener">MOOC-北京理工大学的网络爬虫的课程</a>。</p><h1 id="一准备工作">一、准备工作</h1><h2 id="安装anaconda">1. 安装<a href="https://www.anaconda.com/products/individual" target="_blank" rel="noopener">anaconda</a></h2><p><em>即便已经安装了python也建议安装anaconda，因为Anaconda 附带了一大批常用数据科学包，而且anaconda是建立在conda（包管理器和环境管理器）上的，她可以管理包（安装、卸载、更新包），还可以管理环境，比如python2， python3，同时安装两个版本的python可能造成混乱，又或者你希望一个环境是用tensorflow1.0版本的，另一个用tensorflow2.0版本，这样就可以在对应环境下处理不同需求的任务了。总之，conda是一个非常不错的工具。</em></p><h2 id="安装爬虫需要的requests库">2. 安装爬虫需要的Requests库</h2><p><strong>Requests是一个基于Apache2协议开源的Python HTTP库</strong>，总之是进行网络爬虫时必备的一个库文件。</p><p>因为我用了conda，所以我的命令是：</p><p><code>conda install requests</code></p><p>如果没有安装conda或者不用conda的命令，也可以pip的方式：</p><p><code>pip install requests</code></p><h2 id="测试安装是否成功">3. 测试安装是否成功</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code </span><br><span class="line"><span class="number">200</span>  <span class="comment">#这样表示访问成功</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.encoding = <span class="string">'utf-8'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.text <span class="comment">#打印出当前网页内容</span></span><br></pre></td></tr></table></figure><p>打印的结果如下：</p><figure><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gezvkx2zwvj30h30badp5.jpg" alt="image-20200521104436075" /><figcaption>image-20200521104436075</figcaption></figure><p>以上则说明安装成功！：）</p><h1 id="二requests库">二、Requests库</h1><h2 id="response对象">1.Response对象</h2><p>在上一节中第3小节中，可以看到获取网页资源的方法就是：</p><p><code>r = requests.get(url)</code></p><p>这里<code>.get(url)</code>相当于构造了一个向服务器请求资源的Request对象，其返回的内容的为r，这是Response对象，包含服务器所含的所有相关资源。</p><p>这里我们重点介绍一下Response对象。</p><p>同样在上一节我们已经看到了Response对象的一个属性，<code>r.status_code</code>用于检测请求状态，返回200说明访问成功。那么我们需要了解到Response对象的几个重要的属性：</p><table><thead><tr class="header"><th>属性</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>r.status_code</td><td>HTTP请求的返回状态，200表示连接成功，404表示失败</td></tr><tr class="even"><td>r.text</td><td>HTTP响应内容的字符串形式，即url对应的页面内容</td></tr><tr class="odd"><td>r.encoding</td><td>从HTTP header中猜测的响应内容编码方式</td></tr><tr class="even"><td>r.apparent_encoding</td><td>从内容中分析出的响应内容编码方式（备选编码方式）</td></tr><tr class="odd"><td>r.content</td><td>HTTP响应内容的二进制形式</td></tr></tbody></table><p>其中<code>r.text</code>是根据<code>r.encoding</code>显示网页内容的，并且<code>r.encoding</code>是用于告知网站的编码方式，如果在header中不存在charset字段，那么编码默认为ISO-8859-1，而<code>r.apparent_encoding</code>是根据网页内容分析出的编码方式。如执行下述操作，可以看出这两种的不同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.encoding</span><br><span class="line"><span class="string">'ISO-8859-1'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.apparent_encoding</span><br><span class="line"><span class="string">'utf-8'</span></span><br></pre></td></tr></table></figure><p>如果直接利用第一种编码方式输出<code>r.text</code>的话返回的是乱码，但是如果我们通过设置<code>r.encoding</code> 为分析出的<code>'utf-8'</code>的话，那么<code>r.text</code>返回的就会包含百度页面的一些中文字，是我们能看懂的一些东西。</p><p>这里还要再科普一下各种编码方式，下面的东西是我在一个博客<a href="https://blog.csdn.net/zhanghuaichao/article/details/77862037" target="_blank" rel="noopener">zhanghuaichao</a>上看到的，我简单的整理了一下，缩短了这个故事:</p><p>首先最一开始计算机在美国广泛使用，其用来存储英语的文字时，设计了叫<strong>ANSI的Ascii编码</strong>，一共有127号。后来世界各国都开始使用计算机，但是很多国家文字不是英文，ASCII里面没有，于是利用127号之后的空位来表示新的字母、符号，从128到255被称为<strong>扩展字符集</strong>。这时已经占满了可表示的所有状态。</p><p>等后来中国人用计算机时，由于汉字数量十分多，于是人们巧妙的利用两个大于127的字符连接在一起的时候表示一个汉字，这样的组合就能够满足大约7000多个简体汉字了。在这些编码里，还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的&quot;全角&quot;字符，而原来在127号以下的那些就叫&quot;半角&quot;字符了。于是这种汉字编码方案就被称为<strong>“GB2312”</strong>，是对 ASCII 的中文扩展。后来这个方案还是不够用，于是不在要求低字节的是127号之后的码了，只要第一个字节大于127就表示这是一个汉字的开始。这就被称为了<strong>GBK标准</strong>，其在GB2312基础上又增加了近20000个新的汉字。少数民族的语言加入进来以后，<strong>GBK扩展成了GB8030</strong>。中国的程序员们就叫这一系列汉字编码为 <strong>&quot;DBCS&quot;（Double Byte Charecter Set 双字节字符集）</strong>。</p><p>由于每个国家都和中国一样有一套这样的编码标准，所以谁都不理解谁，针对不同编码方式的东西还要下载相应的字符系统，非常麻烦，于是这时，一个叫 ISO （国际标准化组织）的国际组织决定着手解决这个问题。他们废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码，也就是如今的<strong>&quot;UNICODE&quot;</strong>。UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符。</p><p>UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 <strong>UTF（UCS Transfer Format）</strong>标准出现了，UTF8就是每次8个位传输数据。UTF-8就是在互联网上使用最广的一种unicode的实现方式。</p><p><em>那么这里面似乎没有提到ISO-8859-1，这个单字节编码，此字符集主要支持欧洲使用的语言。</em></p><p><em>所以不难知道为什么我们get百度的资源时，如果不指定<code>r.encoding</code>，就会乱码了，因为百度中的中文字符编码方式是不同的。</em></p><h2 id="requests库异常">2.Requests库异常</h2><p>在爬取过程中，同我们写程序一样，都会遇到各种各样的异常问题，这就需要我们理解并处理好这些异常情况，从而可以帮助我们更好的爬取网页。</p><p>Requests库的异常</p><table><thead><tr class="header"><th>异常</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>requests.ConnectionError</td><td>网络链接错误异常，如DNS查询失败、拒绝连接等</td></tr><tr class="even"><td>requests.HTTPError</td><td>HTTP错误异常</td></tr><tr class="odd"><td>requests.URLRequired</td><td>URL缺失异常</td></tr><tr class="even"><td>requests.TooManyRedirects</td><td>超过最大重定向次数、产生重定向异常</td></tr><tr class="odd"><td>requests.ConnectTimeout</td><td>连接远程服务器超时异常</td></tr><tr class="even"><td>requests.Timeout</td><td>请求URL超时，产生超时异常</td></tr></tbody></table><p>这里在补充一些额外小知识：</p><ul><li>重定向是指假设你现在所处的位置是一个论坛的登录百页面，你填写了帐号，密码，点击登陆，如果你的帐号密码正确，就自动跳转到论坛的首页，不正确就度返回登录页；这里的自动跳转，就是重定向的意思。或者可以说，重定向就是，在网页上设置一个约束条件，条件满足，就自动转入到其它网页、网址。</li><li>ConnectTimeout和Timeoout区别：<ul><li>connectTimeout: 仅连接服务器时超过一定时间。</li><li>Timeout: 从访问请求发出到获取网页资源超过一定时间。</li></ul></li></ul><p>捕获上述异常状态时可以用到<code>r.raise_for_status()</code>来表示。如果状态不是200，那么就为引发异常。由此为了确保稳定安全的网络爬取，这里给出了一个通用的<strong>爬取框架</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding <span class="comment">#这里用上一小节讲到的知识就能够理解了</span></span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"产生异常"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    url = <span class="string">"http://www.baidu.com"</span></span><br><span class="line">    print(getHTMLText(url))</span><br></pre></td></tr></table></figure><h2 id="http协议和requests库方法">3. HTTP协议和Requests库方法</h2><p>在一开始安装Requests库时提到Requests是一个基于Apache2协议开源的Python HTTP库，这其中的HTTP（Hypertext Transfer Protocol）是指互联网的超文本传输协议，我们可以利用HTTP协议对网络资源进行一系列的操作（请求资源、删除资源等）。</p><p>HTTP是基于请求和响应模式的、无状态的应用层协议，理解起来就是用户发出请求，服务器作出响应，无状态指请求之间没有关联。</p><p>HTTP采用URL作为定位网络资源的标识符，URL是通过HTTP协议存取资源的Internet路径，一个URL对应一个数据资源，其格式如下：</p><p><code>http://host[:post][path]</code> <code>host</code>: 合法的Internet主机域名或ip地址 <code>port</code>: 端口号，缺省为80 <code>path</code>: 请求资源的路径</p><p>综上我理解的就是，Requests库可以理解成一个专门应用在HTTP协议上的工具，从而使得HTTP协议可以通过URL来完成对网络资源的获取和管理。</p><table><thead><tr class="header"><th>HTTP方法</th><th>Request方法</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>GET</td><td>requests.get()</td><td>获取URL位置资源（全部资源）</td></tr><tr class="even"><td>HEAD</td><td>requests.head()</td><td>获取URL位置资源的头部信息</td></tr><tr class="odd"><td>POST</td><td>requests.post()</td><td>向URL位置后的资源附加新的数据</td></tr><tr class="even"><td>PUT</td><td>requests.put()</td><td>向URL位置存储一个资源，覆盖原URL位置的资源</td></tr><tr class="odd"><td>PATCH</td><td>requests.patch()</td><td>局部更新URL位置的资源，改变该处资源的部分内容</td></tr><tr class="even"><td>DELETE</td><td>requests.delete()</td><td>删除URL位置存储的资源</td></tr></tbody></table><p>注意：</p><ul><li>如果资源很大的时候，GET就不合适了，可以获取HEAD信息，提前分析资源的内容。</li><li>PUT和PATCH，PUT是修改了全部字段，而PATCH只是修改了部分指定字段</li></ul><h2 id="requests库方法详解">4. Requests库方法详解</h2><p><code>requests.request(method, url, **kwargs)</code></p><ul><li><p>method: 请求方式，对应get/head/post/put/patch/delete/options，共7个。</p><ul><li>例：<code>r = requests.request('GET', url, **kwargs)</code></li><li>OPTIONS这个方式用的比较少，所以这里不多做介绍。</li><li>各种请求方式也可以直接利用封装好的方法，如：<code>r = requests.get(url, **kwargs)</code></li></ul></li><li><p>url: 页面的链接地址。</p></li><li><p>**kwargs: 控制访问的参数，均为可选项，共13个。</p><ul><li><p>params: 字典或字节序列，作为参数增加到url中。</p><ul><li>```python &gt;&gt;&gt; import requests &gt;&gt;&gt; url = &quot;http://www.baidu.com&quot; &gt;&gt;&gt; kv = {'key1':'value1', 'key2':'value2'} &gt;&gt;&gt; r = requests.get(url, params=kv) &gt;&gt;&gt; print(r.url) http://www.baidu.com/?key1=value1&amp;key2=value2 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 根据上面的这个例子，我们可以看到一些参数添加到了url链接中，那么实际情况下，就可以根据这些关键字筛选部分资源返回来。</span><br><span class="line"></span><br><span class="line">- data:字典，字节序列或文件对象，作为Request的内容。</span><br><span class="line"></span><br><span class="line">  - 作用：向服务器提交资源时使用，把提交的内容存放到指定的url位置中。</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;python</span><br><span class="line">    &gt;&gt;&gt; body &#x3D; &#39;主体内容&#39;</span><br><span class="line">    &gt;&gt;&gt; r &#x3D; requests.post(url, data&#x3D;body)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>json: JSON格式的数据，作为Request的内容</p><ul><li><p>其作用也可以提交资源</p></li><li><p>```python &gt;&gt;&gt; kv = {'key1':'value1', 'key2':'value2'} &gt;&gt;&gt; r = requests.post(url, json=kv) <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- headers: 字典, HTTP定制头</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;python</span><br><span class="line">    &gt;&gt;&gt; hd &#x3D; &#123;&#39;user-agent&#39;:&#39;Chrome&#x2F;10&#39;&#125; # 用Chrome10版本访问url</span><br><span class="line">    &gt;&gt;&gt; r &#x3D; requests.get(url, headers&#x3D;hd)</span><br></pre></td></tr></table></figure></p></li><li><p>上述例子中就是模拟用不同浏览器访问url。</p></li></ul></li><li><p>cookies: 字典或CookieJar, Request中的cookie。从HTTP协议中解析cookies。</p></li><li><p>auth: 元组，支持HTTP认证功能。</p><p><em>cookies和auth都是HTTP高级功能</em>。</p></li><li><p>files: 字典类型，传输文件。</p><ul><li>```python &gt;&gt;&gt; fs = {'file':open('data.xls','rb')} &gt;&gt;&gt; r = requests.post(url, files=fs) <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- timeout: 设定超时时间，秒为单位</span><br><span class="line"></span><br><span class="line">  - 如果超时会返回一个timeout异常。</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;python</span><br><span class="line">    &gt;&gt;&gt; r &#x3D; requests.get(url, timeout&#x3D;10)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>proxies: 字典类型，设定访问代理服务器，可以增加登录认证</p><ul><li>设定访问的代理服务器，这样在访问url链接时，就是用的代理服务器的地址，可以有效防止爬虫逆追踪。</li></ul></li><li><p>allow_redirects: True/False，默认为True，重定向开关。</p></li><li><p>stream: True/False，默认为True，获取内容立即下载开关。</p></li><li><p>verity: True/False默认Ture，认证SSL证书开关。</p></li><li><p>cert: 本地SSL证书路径。</p><p><em>上述四个字段对应的都是一些高级功能，暂不需了解。</em></p></li></ul></li></ul><p>上述介绍了很多，但是其实我们最常使用的就是get方法和head方法，以及一些常见参数的应用。</p><hr /><p>哇终于码完了第一篇关于爬虫的文章，希望还有后续啊！！！本来一开始学爬虫是为了解决点自己的一些任务，结果手动任务解决完了，爬虫才学了一个get网页资源。。。</p><p>不过，无论怎么说，爬虫还是蛮有用的，不知道以后还有没有机会用，不过必要时候可以装一装。自己也是懂爬虫的人啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是为了记录网络爬虫学习过程中的笔记和自己的一丢丢理解，希望可以通过本文以及如果有后续文章的话，能够掌握网络数据爬虫和网页解析的基本能力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络爬虫" scheme="http://zymdragonggg.github.io/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="网络爬虫" scheme="http://zymdragonggg.github.io/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
      <category term="Requests库" scheme="http://zymdragonggg.github.io/tags/Requests%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>强化学习---入门基础</title>
    <link href="http://zymdragonggg.github.io/2020/05/01/RL-basic/"/>
    <id>http://zymdragonggg.github.io/2020/05/01/RL-basic/</id>
    <published>2020-05-01T08:57:41.000Z</published>
    <updated>2020-05-01T14:58:54.646Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍强化学习的入门基础知识。</p><a id="more"></a><p>入门强化学习已经有半年多了，现在想着把以前做的笔记分享一下。一是帮助自己巩固，二是帮助大家。内容可能还不能做到方方面面都充足，但是逻辑上目前个人看来还是比较通畅的，如果大家有疑问也请提出。接下来让我们开始学习吧！</p><h1 id="一强化学习的应用">一、强化学习的应用</h1><p>现如今强化学习（Reinforcement Learning，RL）越来越火热，应用到了各行各业之中。最常见的就是用强化学习玩Atari游戏了，不过感觉真正让强化学习逐渐备受重视的就是Alpha-Go下围棋的胜利了，除此以外强化学习还会用于机器人、自动化的一些应用领域上，如今无人驾驶领域对于强化学习这一技术也逐渐重视了。</p><table><thead><tr class="header"><th style="text-align: center;"><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge9s77hwo5j305r03swem.jpg" title="Atari" alt="image-20200428210255802" /></th><th><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge9s7ayzpzj30bj06iwjf.jpg" alt="image-20200428210307527" title="Alpha-Go" style="zoom:55%;" /></th><th><img src="https://static.leiphone.com/uploads/new/article/740_740/201510/56209fa5741d6.jpg?imageMogr2/format/jpg/quality/90" alt="查看源图像" style="zoom:25%;" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Atari游戏</td><td>Alpha-Go</td><td>无人驾驶</td></tr></tbody></table><h1 id="二机器学习分支---强化学习">二、机器学习分支---强化学习</h1><p>机器学习通常可以分为<strong>有监督学习</strong>和<strong>无监督学习</strong>两类。强化学习也是机器学习的一类，但是不属于上述的任何一类。三者的关系可以归结为下图：</p><div data-align="center"><p><img src ="https://tva1.sinaimg.cn/large/007S8ZIlly1ge9sg0f5ddj309c093wgs.jpg"></p></div><p>首先我们先了解一下有监督和无监督学习。两者的数据都是<strong>静态的</strong>，也就是说这些数据拿来训练以后不会在有其他的交互作用，再换句话说，只要有足够的数据样本，最终都能够训练出一个模型出来。</p><p><strong>有监督学习（Supervised Learning）</strong>：从带标签（label）的样本中学习后得到一个决策模型。</p><p><strong>无监督学习（Unsupervised Learning）</strong>：通过在无标签的数据中发现隐藏结构从而构建一个决策模型。</p><p>而强化学习的数据是<strong>动态的</strong>，需要和环境不断交互，数据都是在和环境交互过程中产生的。学习者不会被告知在这个状态应该采取什么动作，而是必须通过尝试去发现哪些动作会产品丰厚的收益，进而获得经验，<strong>从经验中学习</strong>哪些决策会带来好的回报，最终的目的是<strong>最大化奖励回报</strong>。</p><h1 id="三强化学习简述">三、强化学习简述</h1><h2 id="强化学习的特性">1. 强化学习的特性</h2><ul><li><strong>Trial-and-error（试错）</strong></li><li><strong>Delayed reward（延迟奖励）</strong></li></ul><p>针对上述两点特性，这里举一个简单的例子：</p><p>小朋友Jack想要拿到好成绩，于是不断的好好学习，最后拿到了一个不错的成绩，但是身心感觉很疲惫。后来Jack太累了，于是尝试学习过程中加入玩游戏，最好考试反而也拿到不错成绩，而且身心也感到愉快。这验证了一句：“All work and no play makes Jack a dull boy！！！”</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geazlzw3tuj30ms07oq87.jpg"></p><ul><li><p>Jack尝试通过玩游戏的方式让自己变得快乐，但这同时会带来成绩下降的风险，这就可以理解为一个试错的过程，因为Jack在尝试玩游戏的时候也不知道会带来什么的结果。</p></li><li><p>而获得好的成绩和身心感受就可理解为延迟奖励，经过和环境互动后，拿到奖励。</p></li></ul><h2 id="强化学习的学习过程">2. 强化学习的学习过程</h2><p>下图是强化学习书里面的一幅图，很好的描述了强化学习的学习过程。</p><p><img src ="https://tva1.sinaimg.cn/large/007S8ZIlly1geazpccqnoj30em05ejrx.jpg"></p><p>强化学习就是智能体（agent）通过和环境（environment）互动拿到奖励然后不断成长。智能体就可以理解为刚才例子里的Jack，环境因素可以有很多，比如学习的屋子，甚至智能体本身的特性（疲惫值）都理解成环境。</p><p>其具体交互过程可以详述为以下3步：</p><ol type="1"><li>智能体会观测环境，得到一个当前的环境状态（state: $ s_{t} $）。</li><li>智能体根据状态选择一个动作去执行（action: $ a_{t} $）。</li><li>环境根据所采取的动作，呈现出新的环境状态（state: $ s_{t+1} $），同时向智能体反馈奖励（reward: $ r_{t} $）。然后重复步骤2，直到环境反馈学习结束的提示。</li></ol><p>这种互动表现为一系列的状态，动作和奖励。在我们的问题中奖励始终是我们最关心的对象，智能体的目标就是<span id="jump">最大化期望累积奖励</span>（Return <span class="math inline">\(G_{t} = r_{t+1} + \gamma r_{t+2} +...\)</span>，这里的<span class="math inline">\(\gamma\)</span>是折扣因子，会在下一节进行介绍，这里只需要只要我们优化目标是最大化累计奖励即可）。通过互动，智能体能充分了解环境中的一些规则，从而能够选择合适的动作实现目标，而我们在训练一个聪明的智能体Jack时，其实就相当于去解决<strong>在特定的状态选择哪个动作</strong>能带来最大收益，这就是我们要去解决的问题。</p><h1 id="四马尔可夫决策过程">四、马尔可夫决策过程</h1><p>介绍马尔可夫决策过程（Markov Decision Process，MDP）之前，先阐明其与强化学习的关系：</p><p><strong>MDP是一个基石，相当于一个模型框架，问题如果建模成MDP，那就可以利用强化学习进行有效的求解，若问题不能建模成MDP，那只能说强化学习可能根本无法为你找到一个好的解决方案。</strong></p><hr /><p>好，接下来对MDP进行讲解。</p><p>上一节中我们看到智能体和环境的交互会产生一系列的状态、动作、奖励、状态的序列，而其实MDP就是一个由这样的一个序列组成的。接下来给出其准确的定义：</p><p>MDP是一个元组<span class="math inline">\(&lt;S,A,P,R,\gamma&gt;\)</span>:</p><ul><li><span class="math inline">\(S\)</span> -- 状态的集合</li><li><span class="math inline">\(A\)</span> -- 动作的集合</li><li><span class="math inline">\(P\)</span> --状态转移概率方程</li><li><span class="math inline">\(R\)</span> -- 奖励函数</li><li><span class="math inline">\(\gamma\)</span> -- 折扣因子</li></ul><p>在一个定义好了的MDP下，智能体就可以和环境进行互动，从而观测到状态集合中的一个状态，然后从动作集合里面采取一个动作去执行，这时环境会根据采取动作进行动作的转移得到下一个状态，从而根据奖励函数反馈给智能体一个打了折扣的奖励。</p><p>这里给出更详细的一些解释：</p><ul><li>折扣是指对未来奖励的看重程度，<span class="math inline">\(\gamma\in[0,1]\)</span>，越接近于0说明越没有长远打算，越接近于1说明对未来的重视程度越高，通常来说，这个值都更接近于1。</li><li>在有限的MDP中，<span class="math inline">\(S\)</span>，<span class="math inline">\(A\)</span>，<span class="math inline">\(R\)</span>的元素都是有限的。有限的MDP利用传统的强化学习算法就可以求解，但是无限的MDP由于这些集合变得无限时，就需要采用我后面会提到的深度强化学习的方法进行求解。</li><li>动作可以是离散的动作集合，也可以是连续动作的集合，只不过针对不同的动作集合需要采用不同的算法求解。</li></ul><p>最后给出一个小例子帮助大家更有效的理解MDP：</p><p>状态集合：{A,B,C,D}</p><p>动作集合：{study, play, sleep}</p><p>状态转移：(从一个状态到另一个状态的概率，本例概率转移矩阵如下)</p><table><thead><tr class="header"><th style="text-align: left;"></th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>A</strong></td><td></td><td>0.5</td><td></td><td>0.5</td></tr><tr class="even"><td style="text-align: left;"><strong>B</strong></td><td></td><td></td><td>1.0</td><td></td></tr><tr class="odd"><td style="text-align: left;"><strong>C</strong></td><td>0.6</td><td>0.2</td><td>0.2</td><td></td></tr><tr class="even"><td style="text-align: left;"><strong>D</strong></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>特别解释一下，C状态下选择play可能有$（0.5*0.2+0.5）= 0.6 $的概率到达A状态，还有<span class="math inline">\(0.5*0.4 = 0.2\)</span>的概率到达B和C状态。同时需要注意这个例子中，D为终态，意味着MDP终止。</p><p>奖励和折扣因子都是可以人为给定的，这里就没有给出具体数值，不过在下一节会带入这些内容。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gec0lm02qej30a606s74p.jpg"></p><p>从这个例子看来，需要解决的问题就是要学会在特定的状态做某个事情，如：在A状态的时候是应该睡觉好还是学习好，这其实就涉及到了策略的问题，下一节我们开始近一步阐述如何得到好的策略。</p><h1 id="五策略状态值函数和动作值函数">五、策略、状态值函数和动作值函数</h1><h2 id="策略policy">1. 策略（policy）</h2><p>策略简单说就是指在某个状态下选择哪一个动作。策略一般记为$ $，主要为了阐明状态和动作的关系，其定义可以有两种理解：</p><ul><li><p>策略<span class="math inline">\(\pi\)</span>是在给定的状态下动作的分布：<span class="math display">\[ \pi(a|s) = P[A_{t} = a| S_{t} = s] \]</span></p></li><li><p>是从状态集合到动作集合的映射<span class="math display">\[ \pi：S \rightarrow A \]</span></p></li></ul><p>策略可以分为两类：</p><ul><li>确定性策略（Deterministic policy）</li><li>随机性策略（Stochastic policy）</li></ul><p>接下来继续通过上述的例子来理解策略以及策略的分类。在上述例子中，我们可以一一列举出状态和动作的关系，如下就是各种策略： <span class="math display">\[P(a = study|s = A) = 0.5 \\P(a = sleep|s = A) = 0.5 \\P(a = study|s = B) = 1 \\P(a = study|s = C) =0.5 \\P(a = play|s = C) = 0.5\]</span> 这里面确定性的策略就是 <span class="math inline">\(P(a = study|s = B) = 1\)</span>，因为在B状态下只能采取动作study，而其他的几个策略都是存在状态动作映射的可能。</p><hr /><p><em>这里我想要解释一下，可能我们大多时候都会觉得找到最优解就是应该有一个确定性策略，其实未必，有时候随机性策略可能会得到更好的结果，比如我们猜拳或者掷骰子，如果每个人真的是随机出拳和随意投掷骰子，那么我相信确定性策略怕是给不出你好结果。</em></p><hr /><p>当然上述的策略也只是我们人为给出的，如果想要拥有一个“聪明的”智能体，那么就需要让智能体通过不断和环境互动，从而学习到一个好的策略，这个策略可能是确定性的，也可能是不确定性的，也可能是掺杂的。那么如何评判一个策略的好坏呢，这就需要接下来我要介绍的状态价值函数来帮助我们了。</p><h2 id="状态价值函数state-value-function">2. 状态价值函数（state-value function）</h2><p><strong>定义：</strong>状态价值函数<span class="math inline">\(v_{\pi}(s)\)</span>是在MDP中从状态s开始根据策略<span class="math inline">\(\pi\)</span>所获得的期望回报。 <span class="math display">\[v_{\pi}(s) = \mathbb{E}_{\pi}[G_{t}|S_{t} = s]\]</span> 如果忘记<span class="math inline">\(G_{t}\)</span>是什么的，大家去<a href="#jump">第三节的第二小节</a>回顾一下。我们仍采用上述的例子，只不过这次我们加入了奖励，并且为了方便理解，再一次简化了MDP。</p><p>这里我们的状态集合为{A, B, C}，动作集合为{study, sleep}。策略是从A到B和C的概率分别为0.5，从B到C的概率为1，C为终态。奖励设置为在A时采取动作study到达B能够拿到-2的奖励，采取动作sleep到C能拿到0的奖励，在B采取动作sleep到C则能拿到+1的奖励。同时设置折扣因子<span class="math inline">\(\gamma = 1\)</span>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ged00p7uvej309n06b74o.jpg"></p><p>那么每一个状态的价值是多少呢？根据定义我们可以计算出结果如下： <span class="math display">\[v_{\pi}(A) = 0.5 * (0) + 0.5 * (-2 + 1) = -0.5 \\v_{\pi}(B) = 1 * (+1) = 1 \\v_{\pi}(C) = 0\]</span> 我们拿A的状态价值来详细阐明计算过程，在A状态时，有0.5的概率可以到达B拿到-2的结果，还有0.5的概率到达C拿到0的奖励，所以A状态的价值为两种情况下的加和即-0.5。也即意味着在这样的策略下当处于A状态时，能拿到期望奖励为-0.5。</p><p>总的来说<strong>状态价值函数反映的就是这个状态的好坏。</strong>从上述例子可以看出，B状态是要优于AC状态的，那么对于我们来说，我们会尽可能希望我们的智能体处于B状态。因为这时候其期望奖励最大。</p><p>上述的计算过程看着很简单，可是如果当状态集合以及动作集合的元素变得很多的时候，或者无限个元素的时候该怎么办呢？相信手算就会变得很难了。那么就有了下面我们要说的一种方便计算价值函数的一个工具：<strong>贝尔曼期望方程</strong></p><p>贝尔曼期望方程（Bellman expectation equation）--- 将状态价值函数分解为立即奖励加上折扣的后继状态的价值，即： <span class="math display">\[v_{\pi}(s) = \mathbb{E}_{\pi}[R_{t+1} + \gamma v_{\pi}(S_{t+1})|S_{t} = s]\]</span> 这样在计算过程中，只要知道后继状态的价值，那么我们当前状态的价值就可以获悉。如我们知道状态C的价值为0，那么状态B就是<span class="math inline">\(1+ 1 * v_{\pi}(C)\)</span> = 1，那么状态A的价值为$0.5 <em>(0 +1</em>0) + 0.5<em>(-2 + 1</em>1) = -0.5 $。这样倒着计算，是很方便，只是在我这个例子里可能你察觉不到，你可以自己画一个例子去看看比较就知道它有多方便了，这可以省去大量的重复计算。</p><p>我们现在学会了怎么快速计算状态的价值，这样我们就可以去评判策略好坏了。如下图，右图的策略就比左图的策略要好。因为BC状态价值一致的情况下，右图中A状态的价值更高。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ged0udmufoj30h704zwev.jpg"></p><p>这里，我们还要简单介绍一下<strong>最优策略</strong>：最优策略就是在这个策略下所有的状态价值函数都比任何一个策略所带来的状态价值相等或者更高。</p><p>那么如何得到最优策略呢？可以观察到上面两幅图中，在状态A下采取不同的动作会带来状态价值函数的改变，所以接下来就需要我们利用下一节的知识点---<strong>动作价值函数</strong>---来帮助我们去衡量动作能带来的价值。</p><h2 id="动作价值函数action-value-function">3. 动作价值函数（action-value function）</h2><p><strong>定义：</strong>动作价值函数<span class="math inline">\(q_{\pi}(s,a)\)</span>是在MDP中从状态s开始采取动作a并根据策略<span class="math inline">\(\pi\)</span>所获得的期望回报。 <span class="math display">\[q_{\pi}(s,a) = \mathbb{E}_{\pi}[G_{t}|S_{t} = s, A_{t} = a]\]</span> 同样还是利用上一节的例子，我们来看看如何找出最优策略。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ged1app0ryj3084050mxc.jpg"></p><p>每个动作价值根据定义可得： <span class="math display">\[q_{\pi}(A, study) = -2 + 1 = -1 \\q_{\pi}(A, sleep) = 0 \\q_{\pi}(B, sleep) = 1\]</span> 不难看出这里最优策略其实就是红线所标示的，从A到C和从B到C这时的策略是最优的。因为这样的策略下，A的状态价值函数为0，B的状态价值为1，C的为0。A的状态优于之前的例子。</p><p>这里值得一提的是动作价值函数同样可以利用贝尔曼方程进行快速计算，计算公式类似状态价值函数的计算： <span class="math display">\[q_{\pi}(s,a) = \mathbb{E}_{\pi}[R_{t+1} + \gamma q_{\pi}(S_{t+1},A_{t+1})|S_{t} = s,A_{t} = a]\]</span> 这个例子还是非常简单的，随着动作和状态的增多，就不可能一眼看出最优策略了，于是，这就需要我们的智能体不断的和环境交互，不断更新策略，去探索当前状态下所有可能采取的动作，不断选择可以最大化状态价值函数的动作，最终找到那个最优的策略。</p><h1 id="六总结">六、总结</h1><p>至此，其实我们已经掌握了如何让智能体学习的方法，就是利用价值函数来计算动作的好坏，从而找到最优策略。但是之前的求解方式只是适用于状态、动作空间很小的情况，实际上很多智能体要面临的环境是相当复杂的，上述的解法必然不可行，由此有了后面很多的强化学习算法。不过后面好多算法我都还有点小懵，有机会一定好好梳理下来，继续分享！哈哈！</p><h1 id="致谢">致谢</h1><p>最后需要感谢一下我的师弟Gan，今天我写的这个博客其实是基于我们之前做过的PPT搞出来的，思路是我们彼此讲通了的，所以书写时简直感觉不要太清晰，不过也新添加了很多文字描述，毕竟博客文字版本，还是希望能让大家搞得明明白白，毕竟我没法给大家讲了哈哈哈。</p><h1 id="参考文献">参考文献</h1><p>[1] Sutton, R, Barto, A. Reinforcement Learning:An Introduction[M]. MIT Press, 1998.</p><p>[2] David Silver. PPT of Reinforcement Learning. https://www.davidsilver.uk/teaching/</p><p>[3] 莫烦.强化学习. https://www.bilibili.com/video/av16921335</p><hr /><p>好了今天的分享结束！call it a day ! :)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍强化学习的入门基础知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="强化学习" scheme="http://zymdragonggg.github.io/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="强化学习" scheme="http://zymdragonggg.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="机器学习" scheme="http://zymdragonggg.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《用户体验要素》读书笔记</title>
    <link href="http://zymdragonggg.github.io/2020/04/30/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0/"/>
    <id>http://zymdragonggg.github.io/2020/04/30/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0/</id>
    <published>2020-04-30T10:07:08.000Z</published>
    <updated>2020-04-30T10:51:32.089Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要梳理了《用户体验要素》一书的内容，主要帮助自己理清思路，同时希望能帮助大家一起对这本书有一个较为全面的认知。</p><a id="more"></a><p>《用户体验要素》这本书不知道是不是因为我看的译文的缘故，总觉得很多地方晦涩难懂，相比较下《人人》还有《启示录》更容易理解。除此以外，这本书主要围绕网站进行用户体验讲解的，不过我认为里面很多内容都值得学习，可以帮助产品设计过程中做到井井有条。最后，非常推荐大家去看看书中的图，画的都非常好，图比文字好理解的多，并且其中的一些例子也很恰当，可以增深对于用户体验的理解。接下了，奉上本书的全部的内容简介。</p><h2 id="一、用户体验"><a href="#一、用户体验" class="headerlink" title="一、用户体验"></a>一、用户体验</h2><p>用户体验是指“产品如何与外界发生联系并发挥作用”，即人们如何“解除”和“使用”它。</p><p>正确的产品形态绝不是由功能所决定的，而是由“用户自身的心理感受和行为”来决定的。</p><p>任何在用户体验上所做的努力，目的是为了提高效率，“帮助人们工作的更快”和“减少他们犯错的几率”。（内部：员工更喜爱工作，外部：用户更喜欢你的产品）</p><p><strong>以用户为中心的设计（User-Centered Design）</strong>:创建吸引人的、高效的用户体验方法。在开发产品的每一步中，都把用户列入考虑范围。</p><h2 id="二、用户体验要素"><a href="#二、用户体验要素" class="headerlink" title="二、用户体验要素"></a>二、用户体验要素</h2><p>自底向上包含5个元素：战略层-&gt;范围层-&gt;结构层-&gt;框架层-&gt;表现层。</p><ul><li><strong>战略层(strategy)</strong>：产品目标和用户需求。</li><li><strong>范围层(scope)</strong>：决定某一功能是否为需要，功能规格和内容需求。</li><li><strong>结构层(structure)</strong>：确定各种特性和功能最合适的组合方式，交互设计（如何响应用户的请求）和信息架构（合理安排内容元素以促进用户理解）。</li><li><strong>框架层(skeleton)</strong>：按钮、控件、照片和文本区域的位置，完成信息设计，促进理解信息的表达方式，界面设计（用户和产品互动的界面元素），导航设计（屏幕上元素组合）。</li><li><strong>表现层(surface)</strong>：图片文字组成，感知设计。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geaglyvlfpj332c0u0ak3.jpg" alt="用户体验要素"></p><hr><p><em>每一层都是根据下面一层来决定的，但是上层的决定也可能会造成对下层的重新评估，所以一个好的方法是让每一层面的工作在下一个层面可以结束之前完成。</em></p><p><em>用户体验五要素需要针对产品的不同性质拥有不同的描述形式。</em></p><ul><li><strong><em>功能型产品</em></strong>：<em>用于描述功能型的产品类产品。需要思考人们如何完成这个过程。应该打造可以完成任务的工具。</em></li><li><strong><em>信息型产品</em></strong>：<em>用于描述信息型的媒介类产品。需要关注信息对于用户的意义。应该打造可理解、有意义的信息组合。</em></li></ul><h2 id="三、战略层"><a href="#三、战略层" class="headerlink" title="三、战略层"></a>三、战略层</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><ul><li>我们通过产品得到什么。<strong>（产品目标）</strong></li><li>用户通过产品得到什么。<strong>（用户需求）</strong></li></ul><h3 id="2-产品目标"><a href="#2-产品目标" class="headerlink" title="2. 产品目标"></a>2. 产品目标</h3><p>产品目标至关重要，在制定时应注意以下几点：</p><ul><li><p>定义产品目标不应过于急切给出结论，需要定义“成功条件”，而不是“成功的路径”。</p></li><li><p>对于产品目标衡量时应注意成功的标准一定要明确地与用户行为绑定。</p></li></ul><h3 id="3-用户需求"><a href="#3-用户需求" class="headerlink" title="3. 用户需求"></a>3. 用户需求</h3><p>需要搞清两个问题：<strong>用户是谁？这些用户的需求是什么？</strong></p><p>a. 解决第一个问题可采用<strong>用户细分（user segmentation）</strong>的方法，即将用户分成更小的群组，每一群组用户都具有某些共同的关键特征，往往这些群组用户有着共同的需求。</p><p>细分方法：</p><ul><li>人口统计特征，但是有时候并不适用，如，同一年龄段的人会有不同的世界观。</li><li>建立消费心态档案，观察用户的观点和看法。</li><li>用户对技术的熟悉度和适应度。</li><li>用户的经验和专业程度。</li></ul><hr><p><em>通常人们使用信息的方式经常取决于他们的社会和专业角色。</em></p><p><em>不同用户群有不同需求，而且这些需求可能是彼此矛盾的，因此要么只为一种用户设计方案，要么就提供不同的解决方案。</em></p><hr><p>b.解决第二个问题，可以采用以下方法：</p><ul><li>用于收集用户的普通观点：问卷调查、用户访谈、焦点小组。</li><li>用于理解具体的用户行为：用户测试、现场调查</li></ul><p>c. 最后针对调查分析结果<strong>创建人物角色</strong>，也称作用户模型或用户简介。</p><p><em>创建好的人物角色需要和所有参与者都了解，从而可以帮助作出更正确的决定。</em></p><p><em>产品战略是设计用户体验流程的起点，但并不意味着必须一开始就完全确定下来，战略是可以演进和改进的。</em></p><h2 id="四、范围层"><a href="#四、范围层" class="headerlink" title="四、范围层"></a>四、范围层</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>为用户提供什么样的内容和功能。</p><ul><li>功能型产品—-确定功能需求规格。</li><li>信息型产品—-确定内容。</li></ul><p>作用：为产品团队提供一个参考点，让团队知道在做什么，什么事不需要做的。</p><h3 id="2-功能规格"><a href="#2-功能规格" class="headerlink" title="2. 功能规格"></a>2. 功能规格</h3><p>对于功能规格进行描述时，应该注意以下几点：</p><ul><li>Be positive ：不要描述“不应该做什么”，而要描述“防止”不好情况发生。</li><li>Be specific ：尽可能详细的解释清楚状况。</li><li>Avoid subjective language：避免主观语气，可以利用量化的定义来避免。</li></ul><p><em>这一小节建议可以看看书上的例子，比较有助于理解。</em></p><h3 id="3-内容需求"><a href="#3-内容需求" class="headerlink" title="3. 内容需求"></a>3. 内容需求</h3><p>文本、图像、视频、音频</p><p>内容需要日常的维护</p><hr><p><strong><em>最后需要注意的是，一定要在范围内制定清晰的优先级别顺序，这会决定是否采纳意见的首要因素。</em></strong></p><h2 id="五、结构层"><a href="#五、结构层" class="headerlink" title="五、结构层"></a>五、结构层</h2><h3 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>将定义好的用户需求联系起来组成一个整体，使得从抽象的决策与范围问题，转移到更能影响最后的用户体验的具体要素。主要包含两个方面：</p><ul><li>交互设计师—-关注影响用户执行和完成任务的元素。</li><li>信息架构师—-关注如何将信息表达给用户的元素。</li></ul><p><strong>这就要求必须理解用户，理解用户的工作方式、行为和思考方式。</strong></p><h3 id="2-交互设计"><a href="#2-交互设计" class="headerlink" title="2. 交互设计"></a>2. 交互设计</h3><ul><li><p>交互设计关注与描述“可能的用户行为”，同时定义“系统如何配合和响应”这些用户行为。</p></li><li><p><strong>概念模型</strong>：交互组件怎样工作。如何把某个特性处理成用户所熟悉的某个概念，如“购物车”。（这里建议大家读一下书看看解释，不再多做展开。）</p></li><li><p><strong>错误处理</strong>：面对“用户的错误”， 可以采用如下方法：一、设计系统不可能犯错（预防）；二、使错误难以在发生，帮助用户找出并改正（改正）；3.为用户提供从错误中恢复的方式，如“撤销”功能（恢复）。</p></li></ul><h3 id="3-信息架构"><a href="#3-信息架构" class="headerlink" title="3. 信息架构"></a>3. 信息架构</h3><ul><li>信息架构研究的是人们如何认知信息的过程，需要呈现给用户的信息合理并具有意义。</li><li><strong>结构化内容</strong>：设计组织分类和导航结构，提高用户效率。可以利用<strong>由战略层驱动的从上到下的架构方法</strong>，也可以利用<strong>由范围层驱动的由下到上的架构方法</strong>去创建分类体系。</li><li><strong>结构方法：</strong>对信息节点的安排方式<ul><li>层级结构（树、中心辐射）</li><li>矩阵结构：适用有关联性的需求。</li><li>自然结构：不强调“分类”概念。适用娱乐、教育网站。</li><li>线性结构：通常用于小规模的内容，或者大规模需要按照顺序呈现的，如教学资料。</li></ul></li><li><strong>组织原则：</strong>对于节点信息进行组合编排。</li><li><strong>语言和元数据</strong>：设计合理的命名原则，即对描述、标签和术语，要“使用用户的语言”并且“保持一致性”。元数据是信息的信息，用一种结构化的形式描述内容的信息，可以帮助用户更好的理解</li></ul><h2 id="六、框架层"><a href="#六、框架层" class="headerlink" title="六、框架层"></a>六、框架层</h2><h3 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>结构层界定了产品的运作方式，框架层则用于确定产品用什么样的功能和形式来实现。框架层处理的是更精确的细节问题，主要关注独立组件以及它们之间的关系。</p><h3 id="2-界面设计"><a href="#2-界面设计" class="headerlink" title="2. 界面设计"></a>2. 界面设计</h3><ul><li><p>定义：对于功能型产品，需要通过界面设计来确定框架，如按钮、输入框…</p></li><li><p>作用：用于提供给用户做某些事情的能力。</p></li><li>怎么做：选择正确的界面元素，以帮助用户完成任务，使得界面元素容易被理解和使用。</li></ul><h3 id="3-导航设计"><a href="#3-导航设计" class="headerlink" title="3. 导航设计"></a>3. 导航设计</h3><ul><li><p>定义：导航设计是呈现信息的一种界面形式。</p></li><li><p>作用：用于提供给用户去某个地方的能力。</p></li><li><p>设计要求</p><ul><li>提供给用户在网站间跳转的方法。</li><li>必须传达元素之间的关系。</li><li>必须传达内容的用户当前浏览之间的关系。</li></ul></li><li><p>导航类型</p><ul><li>全局导航：提供覆盖整个网站的通路。</li><li>局部导航：提供给用户在这个架构中的“附近地点”的通路。</li><li>辅助导航：对内容进行分类，可以快速到达一类内容。</li><li>上下文导航（内联导航）：嵌入页面内容的一种导航，如：一个在页面文字中的超链接。</li><li>友好导航：提供给用户他们通常不需要的链接，如联系信息、法律声明等。</li><li>远程导航：独立于内容或功能，以自己的方式存在，如网站地图（site map），这类地图通常最多包含两级导航目录。</li><li>索引表：按字母顺序排列的，链接到相关页面的列表。</li></ul></li></ul><h3 id="4-信息设计"><a href="#4-信息设计" class="headerlink" title="4. 信息设计"></a>4. 信息设计</h3><ul><li><p>定义：信息设计是功能和信息两方面都需要做的，把各种设计元素聚合在一起，使得人们能够理解。</p></li><li><p>作用：用于传达想法给用户，呈现有效的信息沟通。</p></li><li>指示标识：将信息设计和导航设计结合在一起，就能告诉用户“他们在哪儿”和“他们能去哪儿”。</li></ul><p><strong>线框图：用于捕获所有在框架层作出的决定，将信息设计、界面设计和导航设计放置在一起，形成一个统一的架构，最终用一个文档来展现。</strong></p><ul><li>通过安排和选择界面元素来整合界面设计。</li><li>通过识别和定义核心导航系统来整合导航设计。</li><li>通过放置和排列信息组成部分的优先级来整合信息设计。</li></ul><h2 id="七、表现层"><a href="#七、表现层" class="headerlink" title="七、表现层"></a>七、表现层</h2><h3 id="1-定义-4"><a href="#1-定义-4" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>解决框架层的逻辑排布的感知呈现问题，如信息元素如何分组和排列，视觉上如何呈现。</p><h3 id="2-合理设计感知"><a href="#2-合理设计感知" class="headerlink" title="2. 合理设计感知"></a>2. 合理设计感知</h3><p>感知包括<strong>嗅觉、味觉、听觉和视觉</strong>，其中<strong>视觉设计</strong>是用户体验设计师最集中需要去研究的。<strong><em>视觉设计不应该是“什么具有美感”，而是应考虑这种视觉设计“是否运作良好”。</em></strong></p><p>视觉设计要忠于用户的眼睛，如果设计成功，那么用户眼睛的移动轨迹模式应该具备两点：（1）它遵循一条流畅的路径，不会被其他元素分散注意力。（2）它为用户提供有效的选择的、某种可能的“引导”。</p><h3 id="3-对比和一致性"><a href="#3-对比和一致性" class="headerlink" title="3. 对比和一致性"></a>3. 对比和一致性</h3><ul><li><p>对比是吸引用户注意力的一个主要工具。对比的策略是让“差异”必须足够清晰。</p></li><li><p>一致性可以有效的传达信息，让用户不会感到疑惑或者焦虑。可以利用栅格来指导部剧保证界面一致性。</p><ul><li>内部一致性：产品在不同地方反应的相同的设计方法，面对这种问题需要只设计一次，然后应用到整个产品中。</li><li>外部一致性：设计在企业其他产品中，使用的相同的设计方法（这里可以理解为明确企业形象）。</li></ul></li><li>保证对比和一致性的方法。<ul><li>利用配色方案和排版<ul><li>需要传达不同信息时才需要使用不同的色彩和排版风格，颜色和排版风格之间要有足够的对比才能吸引用户，但不过过于广泛和多样的使用的颜色和风格，最后需要注意利用一致的方式应用这些东西。</li></ul></li><li>设计合成品和风格指南<ul><li>风格指南确定了视觉设计的每个方面，从小到大的范围内的所有元素。</li><li>影响到产品的每个局部的全局标准（如设计栅格、配色方案、字体标准或标志应用指南）。</li><li>风格指南可以包括某个模块或网站功能的具体标准。</li></ul></li></ul></li></ul><h2 id="八、-要素的应用"><a href="#八、-要素的应用" class="headerlink" title="八、 要素的应用"></a>八、 要素的应用</h2><p>用户体验要素的五层是紧密相关的，无论是上一级的正确决定建立在低一级的错误决策上，还是上一级中的直接的错误决策，都会使你所有的工作变得毫无意义。每一层的要素都要做出正确的、明确的决定，这才能确保你的产品同时满足你的战略目标和用户需求。</p><p>最后附图，是在必应图片里面找的一个，基本和《用户体验要素》一书中的图是一致的。</p><p><img src="http://image.woshipm.com/wp-files/2019/01/s8bl4e9ipgF3eyl3BLLI.jpeg!v.jpg" alt="查看源图像"></p><hr><p>这是看产品的第三本书了，从《人人》到《启示录》再到《用户体验要素》，我发现很多内容都是交叉的，尽管侧重点略有不同，但是知识是融会贯通的。继续学习，提高生产效率！加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要梳理了《用户体验要素》一书的内容，主要帮助自己理清思路，同时希望能帮助大家一起对这本书有一个较为全面的认知。&lt;/p&gt;
    
    </summary>
    
    
      <category term="产品知识" scheme="http://zymdragonggg.github.io/categories/%E4%BA%A7%E5%93%81%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="产品" scheme="http://zymdragonggg.github.io/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="用户体验要素" scheme="http://zymdragonggg.github.io/tags/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0/"/>
    
  </entry>
  
  <entry>
    <title>《启示录 打造用户喜爱的产品》读书笔记</title>
    <link href="http://zymdragonggg.github.io/2020/04/18/%E3%80%8A%E5%90%AF%E7%A4%BA%E5%BD%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://zymdragonggg.github.io/2020/04/18/%E3%80%8A%E5%90%AF%E7%A4%BA%E5%BD%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-18T07:29:27.000Z</published>
    <updated>2020-04-18T09:48:22.536Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对《启示录 打造用户喜爱的产品》一书的梳理，对书中的内容进行了摘抄和总结，是个人认为比较重要的一些内容。从大的层面上解析这本书，意图是帮助自己，也希望同样对产品感兴趣的小伙伴看到这篇文章也能有所获。</p><a id="more"></a><p>上次看完了《人人都是产品经理》，终于又啃完了《启示录》，《启示录》给我的感觉更像是一本教科书，对产品团队人员组成到产品设计开发流程，最后到如何开发富有创意的产品分别给出了详尽的解释。这次我分别针对书中三部分内容做了思维导图，基于更好的理解书本内容以及方便查阅，现对思维导图图进行文字版的梳理同时加上一些个人理解，如有不合理之处，希望可以指出甚至一起探讨，共同进步。</p><h2 id="第一部分—人员"><a href="#第一部分—人员" class="headerlink" title="第一部分—人员"></a>第一部分—人员</h2><p>产品是由团队设计开发的，要了解产品团队有哪些关键角色以及其职责，良好的团队组成以及合作有助于产品成功的推行。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdxyvm410mj31jv0u0qsl.jpg" alt="产品人员"></p><p>一个产品团队主要包含以下6种角色：</p><h3 id="1-产品经理"><a href="#1-产品经理" class="headerlink" title="1. 产品经理"></a>1. 产品经理</h3><p>产品经理负责底层产品需求，这一角色决定用户体验，非常重要。</p><p><strong>a. 主要职责：</strong></p><ul><li><p>产品机会评估：审核产品创意，判断价值（可以利用MRD（市场需求文档）来完成这项工作）。</p></li><li><p>定义要开发的产品：寻找解决方案，可以用PRD（产品需求文档）来完成这项工作。</p><p>包括基本的产品特征和功能，产品的用户体验，产品的发布标准产品价值：产品需要解决什么问题。</p></li></ul><p><strong>b. 产品经理需要具备哪些素质</strong>：</p><ul><li><strong>对产品的热情</strong>—&gt; 这里可以有一个常见的面试问题：自己喜欢的产品，以及喜欢的原因，聊聊不喜欢的产品，如果有机会怎么改善自己喜欢的产品。</li><li><strong>用户立场</strong>：可以在用户角度换位思考，融入目标市场。</li><li><strong>智力：</strong>注重解决问题的思路和方法。</li><li><strong>职业操守：</strong>对产品充满热情，时刻为产品关注和忧虑。</li><li><strong>正直：</strong>公正对待每一个人，以德服人。</li><li><strong>信心</strong></li><li><strong>态度：</strong>愿意承担风险，承担责任，能够预见和解决问题。</li><li><strong>技能：</strong>掌握一些重要的技能。</li><li><strong>运用技术的能力：</strong>不仅要理解，还要发现技术的潜力，挖掘技术的应用潜力。</li><li><strong>注意力：</strong>不但遵循公司规定，还要自律。</li><li><strong>时间管理：</strong>能够做到区分重要任务和紧急任务，合理规划和安排时间。</li><li><strong>沟通技能：</strong>以理服人。</li><li><strong>商业技能：</strong>能和各个部门的人员沟通、讨论。</li></ul><p>最后书中一句话谨记在心，无论什么职位，尤其是职位越高，我觉得这句话越有用：</p><blockquote><p>永远不要告诉别人怎么做。告诉他们做什么，他们自然会发挥天赋，给你惊喜。 —-巴顿将军的忠告</p></blockquote><h3 id="2-交互设计师"><a href="#2-交互设计师" class="headerlink" title="2. 交互设计师"></a>2. 交互设计师</h3><p>也称为信息架构师、用户界面设计师、用户体验架构师。</p><p><strong>主要职责：</strong>确保产品同时具有可用性和价值。可用性指用户明白如何使用，价值指用户对产品的渴求程度。</p><h3 id="3-项目管理人员"><a href="#3-项目管理人员" class="headerlink" title="3. 项目管理人员"></a>3. 项目管理人员</h3><p>这一职位的人员可能需要承接不同产品经理的功能需求。</p><p><strong>主要职责：</strong>制定计划和跟踪进度。</p><h3 id="4-开发团队"><a href="#4-开发团队" class="headerlink" title="4.开发团队"></a>4.开发团队</h3><p>软件工程师也称为产品开发人员或软件开发人员，有些还被称为IT（信息技术）团队。</p><p><strong>主要职责：</strong>开发产品，开发团队多为用户，IT团队多为公司内部开发软件。</p><p><em>开发团队最了解那些产品构思可行，可通过以下几种方式帮助产品经理完善产品定义：</em></p><ul><li>邀请开发人员参加产品原型测试。</li><li>向开发人员了解最新技术发展动向。</li><li>让开发人员参与初期产品评估和定义。</li></ul><p>同时产品经理应配合开发团队，要注意以下两点：</p><ol><li>产品定义不会是最终产品，而是满足基本要求的产品。</li><li>一旦进入开发阶段，要避免修改产品需求和设计。</li><li>开发和产品异地时，需要借助高保真原型进行交流，可以派主程序员和产品共同工作。</li><li>余量（headroom）：<strong>在产品管理上为开发团队预留20%的自主时间让他们可以有时间去完善代码，避免重写代码，要预留一定的技术能力，为事务增长预留空间，为新增功能预留空间。</strong></li></ol><h3 id="5-运维团队"><a href="#5-运维团队" class="headerlink" title="5. 运维团队"></a>5. 运维团队</h3><p><strong>主要职责：</strong>保证服务正常运行。</p><h3 id="6-产品营销人员"><a href="#6-产品营销人员" class="headerlink" title="6. 产品营销人员"></a>6. 产品营销人员</h3><p><strong>主要职责：</strong>负责高层商业需求。对外发布消息，宣传产品。</p><h2 id="第二部分—流程"><a href="#第二部分—流程" class="headerlink" title="第二部分—流程"></a>第二部分—流程</h2><p>这一部分讨论探索以及开发富有创意的产品时的流程和成功经验。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdxwtn9e73j30u00u14qq.jpg" alt="流程"></p><h3 id="1-评估产品机会"><a href="#1-评估产品机会" class="headerlink" title="1. 评估产品机会"></a>1. 评估产品机会</h3><ul><li>产品价值：产品要解决什么问题？</li><li>目标市场：为谁解决这个问题？</li><li>市场规模：成功机会有多大，能赚到多少？</li><li>度量指标或收益标准：怎么判断产品成功与否？</li><li>竞争格局：有哪些同类产品？</li><li>为什么我们最适合做这个产品？</li><li>市场时机：时机合适吗？</li><li>营销组合策略：如何把产品推向市场？</li><li>解决方案要满足的条件：成功的必要条件是什么，一些特殊需求，依赖因素和约束条件？</li><li>给出评估结论（继续或放弃）。</li></ul><h3 id="2-产品探索"><a href="#2-产品探索" class="headerlink" title="2. 产品探索"></a>2. 产品探索</h3><p>定义正确的产品（探索出兼具功能性与设计性产品）。</p><ul><li>产品评估，拜访潜在用户，收集需求。</li><li>和交互设计师一起制作产品原型。</li><li>利用产品原型开展用户测试。</li><li>完成产品用例，和开发团队一起评审产品原型和说明文档。</li></ul><p><em>注意：一旦进入执行阶段，工作中心就重心在开发、测试、发布了。<strong>但是可以在进入开发阶段后，开始准备下一版本的制定。</strong></em></p><h3 id="3-产品原则"><a href="#3-产品原则" class="headerlink" title="3. 产品原则"></a>3. 产品原则</h3><p>产品原则是产品团队的目标和愿景，即确立什么重要什么不重要，那些是根本的、战略性的。</p><ul><li>究竟解决什么问题。</li><li>为谁解决。</li><li>达到什么目标。</li><li>每个目标的优先级。</li></ul><h3 id="4-产品评审团"><a href="#4-产品评审团" class="headerlink" title="4. 产品评审团"></a>4. 产品评审团</h3><p>决定产品战略方向，从宏观上监督产品研发流程合理配置资源。</p><ul><li>启动评估产品，进行评估产品机会。</li><li>根据评估结果，决定定义产品解决方案。</li><li>评审原型，用户测试结果、成本估算，决定是否开发产品。</li><li>评审最终产品、决定是否发布。</li></ul><h3 id="5-特约用户"><a href="#5-特约用户" class="headerlink" title="5. 特约用户"></a>5. 特约用户</h3><p>特约用户可帮助产品经理深入洞察目标用户需求，从而赢得用户对产品的推荐，这种人通常具有一定影响力，必须合理筛选。</p><h3 id="6-市场调研"><a href="#6-市场调研" class="headerlink" title="6. 市场调研"></a>6. 市场调研</h3><ul><li><p>作用（可以帮助解决一系列问题）</p><ul><li>了解谁是目标用户。</li><li>用户会怎样使用产品。</li><li>用户能明白怎么使用产品吗？障碍在哪里。</li><li>用户为什么选择你的产品。</li><li>用户喜欢产品的哪些特点。</li><li>用户希望如何改进产品，增加哪些功能。</li></ul></li><li><p>局限性</p><p>市场调研只能作为依据，不能决定产品研发方向，需要在深入理解用户需求的基础上，明白什么样的解决方案是现阶段可行的。</p></li><li><p>方法</p><ul><li>用户调查（可以利用网络做调查问卷）</li><li>产品使用分析</li><li>数据挖掘</li><li>拜访用户</li><li>人物角色（用户特征记录）<ul><li>在理解各类目标用户基础上建立的人物原型，找到一个体现用户需求与行为的角色人物角色可以帮助筛选重要功能，不必要面面俱到，可以对用户类型进行优先排序，识别重点，设计产品应该针对某一类型用户，把产品发挥到极致。</li></ul></li><li>可用性测试</li><li>同类产品分析    </li></ul></li></ul><h3 id="7-产品说明文档"><a href="#7-产品说明文档" class="headerlink" title="7. 产品说明文档"></a>7. 产品说明文档</h3><p>定义好产品，包括以下几个方面：</p><ul><li>应完整描述用户体验（用户需求、交互设计和视觉设计需求）。</li><li>必须准确描述软件的行为。</li><li>必须直观方式介绍给所有人。</li><li>可以修改。</li></ul><p><strong>满足以上所有要求的产品说明文档为高保证产品原型。</strong></p><h3 id="8-用户体验设计与实现的处理顺序"><a href="#8-用户体验设计与实现的处理顺序" class="headerlink" title="8. 用户体验设计与实现的处理顺序"></a>8. 用户体验设计与实现的处理顺序</h3><ul><li>需求调研和产品设计可同步开展。</li><li>测试和开发可以同步开展。</li><li>但是必须先定义用户体验再开发。</li></ul><h3 id="9-基本产品"><a href="#9-基本产品" class="headerlink" title="9. 基本产品"></a>9. 基本产品</h3><p>满足基本需求（价值、可用性、可行性）的产品，为基本产品。争取设计出只满足基本要求、不可删减的产品。</p><ul><li>定义具备基本功能的产品原型。</li><li>做好技术可行性分析。</li><li>请真实用户验证。</li></ul><h3 id="10-产品验证"><a href="#10-产品验证" class="headerlink" title="10. 产品验证"></a>10. 产品验证</h3><p>产品正式开发、部署前，验证产品说明文档是否符合预期要求。</p><ul><li><p><strong>产品价值测试</strong></p><p>用户是否觉得产品有用，是否愿意购买，有多喜欢，这一部分可以和可用性同时展开。<strong>（重在是否喜欢、满意）</strong></p></li><li><p><strong>产品可用性测试</strong></p><p>PM与交互设计师设需突出产品功能特性，让用户知道如何使用，发现能否实现产品需求。<strong>（重在使用操作流程）</strong></p></li><li><p><strong>产品可行性测试</strong></p><p>在现有技术条件下，能否成功开发出产品。</p></li></ul><h3 id="11-原型测试"><a href="#11-原型测试" class="headerlink" title="11. 原型测试"></a>11. 原型测试</h3><ul><li><strong>物色测试者</strong></li></ul><p>特约用户、展销、网站征集、身边人。</p><ul><li><p><strong>准备测试</strong></p><ul><li>事先拟定测试内容（内容为用户大部分时间执行的操作）。</li><li>提供空白浏览器，看看用户测试前的反应。</li><li>关注用户对原型首页的反应。</li><li>待测试完成后，通过聊天进一步收集信息。</li><li>为每个问题的答案打分。</li><li>不必等原型全部设计好才测试，主要功能有即可。</li></ul></li><li><p><strong>测试环境</strong></p><p>测试环境要轻松，也让用户熟悉越好，面对面测试也非常重要。</p><ul><li>轻松的让测试用户熟悉的地方。</li><li>面对面测试很重要，可以观察对方。</li><li>产品经理一定要参与。</li><li>安排一个人主持测试，一个人记录。</li></ul></li><li><p><strong>测试原型</strong></p><ul><li>测试前不要沟通过多，告知可完成测试后深入交谈。</li><li>告诉测试者不必担心测试失败，只有产品会测试失败。</li><li>让测试者保持平和心情，多观察用户操作。</li><li>测试时不要给用户提示和指导，但是可以去提问测试者并帮助思考，可以口述其行为，或者重复其问题。</li></ul></li><li><p><strong>更新原型</strong></p><ul><li>只要有两三个用户共同反映了一个情况，就可以开始思考提供解决方案。</li><li>改进产品需要明确目标，即在多大程度上可以提升各项指标，要有针对性的改进产品。</li><li>如果产品让人觉得无趣，可以放弃了，节约后期成本。</li></ul></li></ul><h3 id="12-平滑部署"><a href="#12-平滑部署" class="headerlink" title="12. 平滑部署"></a>12. 平滑部署</h3><p>频繁部署极大可能造成用户反感。</p><p><strong>平滑部署措施：</strong></p><ul><li>提前通知。</li><li>加倍做好测试。</li><li>并行部署：新旧版本共同支持，公示旧版使用期限。</li><li>区域性部署：在某个区域，再逐步扩大。</li><li>增量部署：将更新分割成几个部分逐步发布。</li></ul><h3 id="13-快速响应阶段"><a href="#13-快速响应阶段" class="headerlink" title="13. 快速响应阶段"></a>13. 快速响应阶段</h3><p>产品发布后，要及时关注用户的反应，提前做好改进准备，关键不在于是否会出现问题，而在于多快能解决问题，因此应该多关注网站分析工具掌握用户行为。</p><h3 id="14-敏捷方法"><a href="#14-敏捷方法" class="headerlink" title="14. 敏捷方法"></a>14. 敏捷方法</h3><p><strong>定义：</strong>把一个大项目拆成子目标一个个完成，不影响软件运行，反复迭代。<br><strong>优点：</strong>增进客户和开发人员间交流，降低了风险。</p><h3 id="15-瀑布式开发"><a href="#15-瀑布式开发" class="headerlink" title="15. 瀑布式开发"></a>15. 瀑布式开发</h3><p><strong>定义：</strong>开发过程事先分成固定的几个阶段，每个阶段评审过后，才能进入下一阶段。<br><strong>优点：</strong>让人更安心。<br><strong>缺点：</strong>产品验证严重滞后；变更计划代价不菲；无法适应快速变化的市场；（过于理想化，以为能够预见所有问题，只适用规模小的项目）。</p><h3 id="16-如何创新"><a href="#16-如何创新" class="headerlink" title="16. 如何创新"></a>16. 如何创新</h3><ul><li>采用20%原则，即让员工利用20%时间从事创新。</li><li>臭鼬工程：利用自己时间，低调从事创新研究。</li><li>最后要注意，创新不是发现问题，而是用新方法解决已有问题，观察人们对现有产品的不满是创新的最佳途径。</li></ul><h2 id="第三部分—产品"><a href="#第三部分—产品" class="headerlink" title="第三部分—产品"></a>第三部分—产品</h2><p>这一部分介绍富有创意的产品应该具有的鲜明特性，探讨探索产品和开发产品的方法。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdxy2a5bdsj322z0u0aoq.jpg" alt="产品"></p><p><strong><em>硬件为软件服务，软件为用户体验服务，用户体验为情感服务，产品为真正的需求</em></strong>。</p><h3 id="1-特殊要求产品"><a href="#1-特殊要求产品" class="headerlink" title="1. 特殊要求产品"></a>1. 特殊要求产品</h3><ul><li><p><strong>混淆了产品需求和客户需求</strong></p><ul><li>用户不知道自己需要什么。</li><li>用户不知道什么是可行的。</li><li>用户之间缺少沟通，需求难以统一。</li></ul></li><li><p><strong>解决方案</strong></p><p>根据产品原则进行筛选用户需求。</p></li></ul><h3 id="2-善于利用新技术"><a href="#2-善于利用新技术" class="headerlink" title="2. 善于利用新技术"></a>2. 善于利用新技术</h3><p><strong><em>成功的产品往往不是什么新鲜事物，只是新瓶装老酒，之所以成功，是因为这个“新瓶”做的更好、更方便、更便宜，改变了消费者对“老酒”的印象。</em></strong></p><p><strong>方法：</strong></p><ul><li>观察目标市场缺陷跟踪最新的技术。</li><li>跟踪最新的技术。</li></ul><h3 id="3-善于利用情感"><a href="#3-善于利用情感" class="headerlink" title="3. 善于利用情感"></a>3. 善于利用情感</h3><p>了解用户的情感需求，从最基本的生存需求（令人烦恼、头疼的）去挖掘，最后再升华到精神需求（可以实现自我价值的），不断满足用户的情感需求。</p><p><strong>用户情感特征分类</strong></p><ul><li><strong>技术爱好者（技术创新者）：</strong>喜欢新技术，<strong>不值得重视。</strong></li><li><strong>非理性消费者（尝鲜者）：</strong>具有强烈的情感需求，<strong>要重点关注</strong>。</li><li><strong>理性消费者（早期消费大众）：</strong>有情感需求，但不强烈，会买实用、成熟的产品。</li><li><strong>超理性消费者（后期消费大众）：</strong>情感需求弱，但是对产品要求极高，不轻易消费。</li><li><strong>观望者（跟随者）</strong>：只购买公认好用的产品。</li></ul><p><strong><em>产品经理应该注意研究非理性消费者的行为，非理性消费者能够帮助产品经理发现产品的内在价值，还要避免被技术爱好者误导。最后吸引理性和超理性消费者。</em></strong></p><h3 id="4-打造大众网络产品"><a href="#4-打造大众网络产品" class="headerlink" title="4. 打造大众网络产品"></a>4. 打造大众网络产品</h3><p><strong>10大点：</strong>可用性、人物角色、扩展性、持续可用、客户服务、保护用户隐私、口碑营销用户、全球化、平滑部署、用户社区管理。</p><h3 id="5-打造企业级产品"><a href="#5-打造企业级产品" class="headerlink" title="5. 打造企业级产品"></a>5. 打造企业级产品</h3><p><strong>10大点：</strong>可用性、产品正常工作、特例产品、特约用户、销售渠道、客户和用户的需求、产品安装、产品的配置自定义集成、产品升级、销售策略。</p><h3 id="6-打造平台产品"><a href="#6-打造平台产品" class="headerlink" title="6. 打造平台产品"></a>6. 打造平台产品</h3><p>平台产品指一类基础软件，产品管理难度最大。面向的用户包括应用软件供应商、开发人员、终端用户。</p><p>写在最后：产品的书读了第二本啦，在看书的过程中不仅学到了产品的相关知识，还改变了我对很多事物的认知，让我开始看事情看东西有了新的角度和态度，有一种长大了的感觉。</p><p>所以无论怎么说，还是要多读书，这是最重要的！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对《启示录 打造用户喜爱的产品》一书的梳理，对书中的内容进行了摘抄和总结，是个人认为比较重要的一些内容。从大的层面上解析这本书，意图是帮助自己，也希望同样对产品感兴趣的小伙伴看到这篇文章也能有所获。&lt;/p&gt;
    
    </summary>
    
    
      <category term="产品知识" scheme="http://zymdragonggg.github.io/categories/%E4%BA%A7%E5%93%81%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="产品" scheme="http://zymdragonggg.github.io/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="启示录" scheme="http://zymdragonggg.github.io/tags/%E5%90%AF%E7%A4%BA%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>竞品分析实例--有关于流利说英语的竞品分析报告</title>
    <link href="http://zymdragonggg.github.io/2020/04/12/%E7%AB%9E%E5%93%81%E5%88%86%E6%9E%90%E5%AE%9E%E4%BE%8B/"/>
    <id>http://zymdragonggg.github.io/2020/04/12/%E7%AB%9E%E5%93%81%E5%88%86%E6%9E%90%E5%AE%9E%E4%BE%8B/</id>
    <published>2020-04-12T08:53:32.000Z</published>
    <updated>2020-04-27T13:21:05.858Z</updated>
    
    <content type="html"><![CDATA[<p>本文是一份关于流利说英语类英语口语应用的竞品分析报告。</p><a id="more"></a><p>本人第一次尝试写竞品分析报告，历时一个多星期，由于数据资料缺失，对于产品的一些表述还不具备准确性，且内容还不够完善，感觉自己写的有点像每一份产品的分析报告，各路大神如果看到请多提出建议，希望我能够不断学习并进步。</p><h2 id="1-竞品目的"><a href="#1-竞品目的" class="headerlink" title="1. 竞品目的"></a>1. 竞品目的</h2><p>为提高流利说英语的后续迭代方向提供辅助决策（假设）</p><h2 id="2-竞品"><a href="#2-竞品" class="headerlink" title="2.竞品"></a>2.竞品</h2><p>扇贝口语，开言英语</p><ul><li><strong>竞品版本号：</strong><ul><li>流利说：7.16</li><li>扇贝口语：1.9402</li><li>开言英语：4.8.3  </li></ul></li><li><strong>APP图标和首页\学习页总览：</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdr4t5y6vnj30dd0ddq35.jpg" alt="英语流利说"></th><th style="text-align:center"><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdr4ut8rnjj30c10bz74p.jpg" alt="扇贝口语"></th><th style="text-align:center"><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdr4vc3p6cj30j60j6mx6.jpg" alt="开言英语"></th></tr></thead><tbody><tr><td style="text-align:center"><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdm6xfz1pnj30u01t01kx.jpg" alt="流利说"></td><td style="text-align:center"><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdjtkb5ldpj30u01t0djb.jpg" alt="扇贝口语"></td><td style="text-align:center"><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdjtm38u45j30u01t0wh7.jpg" alt="开言英语"></td></tr></tbody></table></div><h2 id="3-竞品分析"><a href="#3-竞品分析" class="headerlink" title="3.竞品分析"></a>3.竞品分析</h2><h3 id="a-体验环境"><a href="#a-体验环境" class="headerlink" title="a. 体验环境"></a>a. 体验环境</h3><ul><li><strong>手机设备：</strong>Hauwei Nova 3 </li><li><strong>系统版本</strong>：Android 9 EMUI 9.1.0</li></ul><h3 id="b-定位"><a href="#b-定位" class="headerlink" title="b. 定位"></a>b. 定位</h3><ul><li><strong>流利说英语：</strong>是一款融合创新口语教学理念和尖端语音评估技术的英语口语学习应用，让你“忍不住开口说英语”，依托于语音识别技术提高口语技能，利用大数据帮助用户自适应学习英语的手机App。</li><li><strong>扇贝口语：</strong>扇贝口语是一款让用户“听得懂、说得出”的英语口语学习应用，作为互联网英语移动学习平台扇贝shanbay旗下专为中国学习者定制的口语学习App，扇贝口语让你“走嘴、走脑又走心”：课前预习-跟读模仿-听音复述-智能打分-精彩解析。</li><li><strong>开言英语：</strong>开言英语是一款主打北美主播情景对话式实用英语的英语学习软件，利用语音识别进行评估判断，将听力与口语测试合一，为用户匹配合适的学习策略。同时结合视障辅助功能，让更多视障用户体验学习乐趣。slogan: 认真学英语也能很享受！/开言英语就是地道。</li></ul><h3 id="c-用户分析"><a href="#c-用户分析" class="headerlink" title="c. 用户分析"></a>c. 用户分析</h3><p>产品的用户使用场景：</p><ol><li>用户类型一： <strong>英语初学者</strong>。赵小强，男，7岁，小学生，刚接触英语，父母重视英语能力对孩子未来生活的影，希望有一款正确的英语学习软件引导孩子养成学习英语的好习惯。</li><li>用户类型二：<strong>英语备考者</strong>。钱小美，女，21岁，大三学生，备考雅思托福，希望可以通过每天的学习，不断积累，从而提高英语口语表达能力。</li><li>用户类型三：<strong>英语爱好者</strong>。孙小萌，女，24岁，英语爱好者，热爱英语文化，喜欢英文歌曲、英文电影等，但只能理解文字内容，不能流利的复述或者自由表达，希望有一个软件能够边学习英语文化边提升自己的英语口语能力。</li><li>用户类型四：<strong>工作需要者</strong>。李小华，男，27岁，从事有英语需求的工作两年，想要晋升或者跳槽，希望通过提升英语能力来增大获得高薪资、高待遇职位的机会，并且希望能够利用上下班的碎片化时间进行学习。</li><li>用户类型五：<strong>出国旅游者</strong>。张大国，男，40岁，喜欢旅游，希望每年都能出国自由行，掌握基本的英语沟通能力，希望能够通过逐渐积累，得到英语能力提升。</li></ol><ul><li><p>核心用户</p><ul><li><strong>流利说英语：</strong>想提升短对话英语口语能力，但没有毅力坚持的学生和职场人士。</li><li><strong>扇贝口语：</strong>在使用扇贝其他软件（扇贝单词、扇贝阅读、扇贝听力）的同时，还想要提升英语口语能力的扇贝用户。</li><li><strong>开言英语：</strong>有一定英语基础并喜欢主播情景对话式学习，希望通过多形式提升英语能力的大学生和职场人士。</li></ul></li><li><p>主流用户</p><ul><li><strong>流利说英语：</strong>喜好闯关模式，打卡积分显示自己英语水平的用户。大多为经济发达地区19-39岁间的大学生和上班族为主，其中女性用户较多。</li><li><strong>扇贝口语：</strong>从扇贝网引流而来的用户，对产品本身认知度不高。</li><li><strong>开言英语：</strong>大多是网上宣传推荐而吸引而来的用户，需要丰富的主播情景对话做支撑，喜好社交，其主流用户多为学生群体和职场人士。</li></ul></li><li><p>用户构成比例</p><ul><li><p><strong>流利说英语：</strong>大多为经济发达地区19-39岁间的大学生和上班族为主，其中女性用户较多。</p></li><li><p><strong>扇贝口语：</strong>分布于经济发达地区，主要是10-29岁学生群体，职场用户相对较少，男性用户较女性用户也更多。</p><p>（注意：因为扇贝口语基本都是从扇贝单词来的，所以用扇贝单词的用户分析做简单认知）</p></li><li><p><strong>开言英语：</strong>分布在经济发达地区，用户多为20-29岁的学生群体和刚入职场的用户。男女比例比较均衡。</p></li></ul><p>以下是三个产品的搜索数据图（开言英语直接搜索，必须要花钱。。所以用了开言这个词，所以可能有误），由于艾瑞咨询要花钱，只能通过对于这三款产品的搜索词来从另一方面了解用户需求。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdisaxouu1j30y10gk417.jpg" alt="image-20200405123623189"></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdisbnj9jwj30xp0b4t9o.jpg" alt="image-20200405123704572"></p><p>从以上三个产品对主流用户分析来看，用户大多都是学生和职场人士，多为经济发达地区的用户。呈上述趋势原因可能有：</p><ul><li>幼儿更忠于线下教学，可以有肢体动作的课程会更加有助于他们的学习，40岁以上的人对英语需求已经不大，已经有了一定的社会能力，不再需要通过学习为自己去创造更多机会了。</li><li>经济不发达的地区宣传力度小，且经济发达地区的用户会更注重英语能力，有更多对英语的需求。</li></ul></li></ul><h3 id="d-功能分析"><a href="#d-功能分析" class="headerlink" title="d. 功能分析"></a>d. 功能分析</h3><ul><li><p><strong>核心竞争力</strong></p><ul><li><strong>流利说</strong><ul><li>拥有庞大的中国人英语数据库</li><li>充分利用人工智能大数据技术为口语打分</li><li>免费的趣味闯关课程</li></ul></li><li><strong>扇贝口语</strong><ul><li>扇贝网丰富的推广渠道和积累的海量用户资源</li><li>注重口语词汇积累</li><li>注重用户的复述口语能力，达到真的能自己说出英语</li><li>配备有丰富的角色扮演课程</li></ul></li><li><strong>开言英语</strong><ul><li>推送能容贴近时事</li><li>免费英语FM，主播情景对话，能充分利用碎片化时间</li><li>课程合理分类且更实用，能满足对于英语某方面能力的提升</li></ul></li></ul></li><li><p><strong>主要功能</strong></p><ul><li><p><strong>流利说功能结构图</strong></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdngsg25ojj310h0u0naf.jpg" alt="英语流利说"></p><p><em>注：定制学部分没有体验过。</em></p><p><strong>功能结构：</strong>主要包含<strong><em>学习</em></strong> 和<strong><em>我</em></strong> 两个模块， <strong><em>学习</em></strong>模块下有 <strong><em>轻松学</em></strong> 和 <strong><em>定制学</em></strong>，一个是免费的吸引用户的，另一个是收费的带来收益的。</p><p><strong>主要功能呈现形式：</strong>主打口语课程练习。</p><p><strong>盈利方式：</strong>主要通过定制学部分盈利，并在每个模块都有付费引导，方便将用户转换为付费用户。</p><p><strong>框架：</strong>界面设计简单明了，便于理解。</p><p><strong>具体细节点评：</strong></p><ol><li>口语课程的学习课程只有通过后才能进行下一阶段的学习，增加了闯关趣味。</li><li>可以加入打卡圈，完成打卡任务可获得金币，增加了用户粘性。 </li><li>个性化推送适合的课程，满足用户的需求。 </li><li>有真人对话、PK这样的功能，增加了用户英语学习体验感。</li><li><em>许多推送内容很鸡肋，没有必要呈现。</em></li></ol></li><li><p><strong>扇贝口语功能结构图</strong></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdngspuf3dj31di0u04h2.jpg" alt="扇贝口语"></p><p><strong>功能结构：</strong>主要包含 <strong><em>首页</em></strong>、<strong><em>课程</em></strong>、<strong><em>发现</em></strong> 和 <strong><em>我的</em></strong> 四个模块， <strong><em>首页</em></strong> 为学习页，包含 <strong><em>我的课程</em></strong>、 <strong><em>全部课程</em></strong>、<strong><em>学习进度</em></strong> 三块。<strong><em>课程</em></strong> 模块下为付费的针对性课程。 <strong><em>发现</em></strong> 下有扇贝产品的生态圈，多为建立用户社交圈。<strong><em>我的</em></strong> 模块下为个人相关的选项设置。</p><p><strong>主要功能呈现形式：</strong>课程学习主要是通过角色扮演和课程练习。</p><p><strong>盈利方式：</strong>通过付费课程收费，以及扇贝商城周边产品收费。</p><p><strong>框架：</strong> <strong><em>首页</em></strong>、<strong><em>课程</em></strong>、<strong><em>我的</em></strong> 页面简单明了，易于操作理解。<strong><em>发现</em></strong>页存在重复内容，重点内容未突出。</p><p><strong>具体细节点评：</strong></p><ol><li>通过角色扮演对用户口语打分，并且可以对影视片段进行评论，对于英语热爱者具有较强吸引力。</li><li>每次口语学习前有重点内容预习、口语练习除了有跟读还有根据中文表说出英语的复述形式、最后有总结，预习和总结可以有助于用户口语学习抓住重点，<em>复述部分较难，</em>需要用户去思考来表达。 </li><li>有良好的英语社交圈，拥有同桌、小组的功能，增强了用户粘性。</li><li><em>口语评判不够严谨，拿到高分比较容易</em>。</li><li><em>发现页重复内容较多，有一些没有太大必要</em>。</li><li><em>口语练习内容不够新鲜。</em></li></ol></li><li><p>开言英语功能结构图</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdoholdktrj30u01bwh3d.jpg" alt="开言英语"></p><p><strong>功能结构：</strong>主要包含 <strong><em>学习</em></strong>、<strong><em>发现</em></strong> 、<strong><em>复习</em></strong> 和 <strong><em>我的</em></strong> 四个模块， <strong><em>学习</em></strong> 是个人学习状况以及本周学习计划和一些付费推送。<strong><em>发现</em></strong> 模块下是对课程做了多种分类，用户可以根据是否免费、主题类型、课程等级、会员课程进行课程选择学习，还包含免费FM，以及热门课程、新鲜课程、个性化课程推送等。<strong><em>复习</em></strong> 模块包含课程笔记、收藏内容、单词本，主要呈现的是学习记录和离线课程两个子模块。<strong><em>我的</em></strong> 模块下为个人相关的选项设置以及产品相关的活动。</p><p><strong>主要功能呈现形式：</strong>主打情景英语场景学习来锻炼词汇、听力、口语能力。</p><p><strong>盈利方式：</strong>一些付费课程。</p><p><strong>框架：</strong>各个页面的内容很合理，学习页和复习页非常简明，发现页内容推送过多。</p><p><strong>具体细节点评：</strong></p><ol><li>免费FM非常有趣，通过两个主播的聊天可以让用户轻松学习到常用口语。</li><li>每周计划最后都有一个周复习，帮助巩固。</li><li>开言的课程可以下载到本地进行学习，进行离线学习。</li><li>可以对课程做笔记，帮助用户加深对课程理解。</li><li>用户可以评论、还可以加入挑战队伍，由此可以增强用户粘性。</li><li>用户反馈页提供在线咨询服务，可以即时响应用户。</li><li><em>发现页中猜你喜欢的栏目下，条目太多，滑很久不到头，应该设置更多按钮，展示成方块列表形式，或者应设置一个滑动条</em>。</li></ol></li><li><p><strong>综合评价：</strong></p><p>英语口语是人们日渐重视的一项生活技能，能否真正帮助用户得到英语能力口语的提升，让用户抱有热情乐于学习英语的学习方式会是英语口语类软件的竞争点。</p><ul><li>流利说目前占据较大的市场，其利用人工智能点评的功能确实能够使得用户口语得以改进，并且提供的闯关功能大大增强用户学习英语趣味。<strong>但是</strong>其更多的是提升英语口语发音，缺乏真正做到让用户说出英语、用户不容易巩固，且好友圈建立的不完善，用户之间做不到沟通，除了关注几乎没有什么可以建立联系的方式。</li><li>扇贝口语建立在扇贝打造的英语社区中，具备大量的用户，其中的角色扮演是其他两个口语软件目前所没有的，也是我个人比较喜欢的一个栏目，并且扇贝的推送相对来说比较简明，没有一页要滑动望不到头的问题。<strong>但是</strong>扇贝口语做的还有很多功能不尽人意，内容不新颖，评分不准确、复述时对于英语口语能力一般的人会具有较大难度。</li><li>开言英语近些年广告打了很多，确实也做的非常吸引人，尤其主播FM的模块，以轻松愉快的方式介绍英语的相关内容，让用户可以学到很多，并且开言英语非常重视学习的巩固，用户可以做笔记，还可以进行每周巩固，且其对于口语学习进行了合理分类，而不像是流利说中按内容推送。<strong>目前存在的问题</strong>我认为是发现页稍有不足和学习内容过长，因为最主要的是让用户利用碎片化时间学习，有时候课程预习就已经10分钟多了。</li></ul><p>我现在学习口语在用流利说，随着不断学习口语发音确实提高很多，但是张口表达还是做不到。扇贝口语只在上面进行过角色扮演，是源于自己对与英语影视的热爱。但是通过对比我发现我目前比较心仪开言英语，虽然没能做到长时间体验开言英语，但是其免费FM深深粘住了我这个用户，我认为真的帮我做到了学习新知识。</p></li></ul></li></ul><h3 id="e-数据分析"><a href="#e-数据分析" class="headerlink" title="e. 数据分析"></a>e. 数据分析</h3><p>以下数据来源均从网络上搜集的，由于学生产品小白，穷+没经验，所以可能这一模块的分析确实做的不好。</p><h4 id="（1）行业发展"><a href="#（1）行业发展" class="headerlink" title="（1）行业发展"></a>（1）行业发展</h4><p>首先在线教育已经是大势所趋，如图是在线教育市场规模，在线教育市场规模越来越大，但是可以看出近些年增长率逐渐下降。个人认为在线教育平台正处于瓶颈期，仍保有很大的进步空间，所以增长率有所下降。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdqu2q9pv7j30hs0eimxo.jpg" alt="中国在线教育市场规模" title="中国在线教育市场规模"></p><p>接下来关注一下在线语言类教育，如下两图分别展示了中国在线语言教育市场规模和用户规模。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdquckpo5lj30ni0aqmxg.jpg" alt="timg" title="中国在线教育市场规模"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdqud43ue4j30ce094t8u.jpg" alt="timg" title="中国在线语言教育用户规模"></p><p>综合两图可以看出中国在线语言教育用户还是不断增长的，随着时代发展，全球一体化，许多工作对人们语言能力的要求也会越来越高，在线语言教育以后不应简单是面向学生，更多应该考虑面向职场人士。</p><p>最后是对英语学习类应用的一个分析，如图所示，语言学习类移动教育应用中英语类占据主要地位，可见英语类教育应用的市场还是相对容易做，也是更大众化、更成熟的方向，其中人们对单词学习需求最大，其次是口语，由此可以看出大多数国人还是更期待看得懂说得出。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdqujhx3qaj30rs0cgmyd.jpg" alt="语言学习类占比" title="语言学习类对比"></p><p>综合上述所有行业数据分析，可以看出，英语口语在线学习应用是市场所需的，仍有发展不足的地方可以去改善，但是竞争也非常激烈。</p><h4 id="（2）产品发展趋势"><a href="#（2）产品发展趋势" class="headerlink" title="（2）产品发展趋势"></a>（2）产品发展趋势</h4><p><em>实在鉴于搜索能力有限，这里只找到了流利说相关数据</em></p><p>下图是流利说累积注册用户及环比增速。从图中可以发现累计注册用户在逐渐增长，但是用户增长速度在逐年下降。分析可能存在原因：1. 流利说定位用户较大，但是英语口语市场发展迅速，各类同类型应用更具有针对性，导致用户增长较少。2. 流利说产品固有吸引用户的模式已经不再新颖，需要注入新的活力和有趣的功能来吸引更多用户。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdquvojwhyj30gh0a0jrm.jpg" alt="累积注册用户" title="累积注册用户及增速"></p><p>下图为流利说活跃用户与付费用户规模对比。从图中可以看到活跃用户逐年增加，但是付费用户占比还是很少。分析可能存在原因：1. 付费内容相对于免费内容没有多大提升，没有展现付费内容优势。2. 用户对于付费学习更倾向于线下学习，在线学习可靠性低。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdqv4ccwxcj30iw0d43z1.jpg" alt="流利说付费和活跃" title="流利说活跃和付费用户"></p><p>最后一个图分析的是流利说付费用户和付费转化率。</p><p><em>小笔记：付费转化率是<strong>让用户从新增/沉默流失 或者是活跃的状态向付费的状态迁移。</strong></em></p><p>付费用户总的趋势来说较稳定，在一定范围内波动，但是付费转化率在逐渐降低。其可能存在的原因类似上图的解释，但是额外需要强调的是，<strong>最主要是产品付费内容做的还是不够好</strong>，因为一开始付费转化率还是较高，用户愿意去尝试，但是逐渐的在下降，愿意尝试的人也少了，总体付费用户也不断流失。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdqv67siacj30ip0c8t94.jpg" alt="付费用户和付费转换率" title="付费用户和付费转换率"></p><p>总的来说，英语口语市场还有很多值得去挖掘的地方，流利说英语目前需要重点提升付费用户，对付费内容应重点深入研究，除此以外，在用户流量上需要多借鉴其他占据市场的应用，发展更新颖的学习模式和学习生态圈，从而吸引更多用户。</p><h4 id="（3）三款产品对比"><a href="#（3）三款产品对比" class="headerlink" title="（3）三款产品对比"></a>（3）三款产品对比</h4><p>下面是三款产品的榜单排名和搜索指数趋势。从榜单来看可以发现流利说排名还是相当高的，但是其评分较差。其背后可能存在原因是流利说用户还是非常多的，但是还有很多不足之处，让用户不满意。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdr9zbbh6hj30se06paaz.jpg" alt="image-20200412205230819"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdra39ncyaj312w0aa40x.jpg" alt="搜索指数趋势"></p><h2 id="4-竞品分析结论"><a href="#4-竞品分析结论" class="headerlink" title="4.竞品分析结论"></a>4.竞品分析结论</h2><p>综合以上，流利说积累了丰厚的用户，且其趣味性的学习可以很好的吸引用户，目前主要任务是在如何留住用户的前提下，吸引更多用户来并将用户转换为付费用户。</p><p>可以看出主流的英语口语的商业模式主要是：学习课程的收费，定制学服务等，由于不知道其他两个产品的背后数据并且个人未亲身体验流利说的收费课程，但是从流利说的数据分析可以看出，其收费内容的改进点仍值得深入探究挖掘。</p><p>根据和其他两个竞品的对比，结合流利说自己的特点，后续迭代可以改进的点有以下五个方面：</p><ol><li><strong>探究其他新颖的学习模式</strong>，提升英语口语学习的乐趣，吸引更多用户，如：可以加入角色扮演和学习开言英语的情景主播的形式。</li><li><strong>改善收费课程的学习模式</strong>，让用户学英语看到学习的反馈，从而让更多用户愿意转换为付费用户并且愿意帮助宣传和逐渐成为“忠实粉丝”。</li><li><strong>对学习内容进行良好的分类</strong>，引进优质的具有<strong>针对性、个性化</strong>的课程学习。</li><li><strong>需大力发展用户社交圈</strong>，拉近用户之间关系，让用户参与到学习口语的讨论中。</li><li><strong>添加离线学习模式，加入课程预习以及课程复习</strong>。</li></ol><p>好啦以上就是今天的竞品分析报告，接触产品这一个领域的初衷是成为产品经理，不过随着不断的学习发现产品给了我更多的思考与认知，无论今后路途如何，相信今天做的都是对未来自己有意义的事！加油～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是一份关于流利说英语类英语口语应用的竞品分析报告。&lt;/p&gt;
    
    </summary>
    
    
      <category term="产品知识" scheme="http://zymdragonggg.github.io/categories/%E4%BA%A7%E5%93%81%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="产品" scheme="http://zymdragonggg.github.io/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="竞品分析" scheme="http://zymdragonggg.github.io/tags/%E7%AB%9E%E5%93%81%E5%88%86%E6%9E%90/"/>
    
      <category term="流利说英语" scheme="http://zymdragonggg.github.io/tags/%E6%B5%81%E5%88%A9%E8%AF%B4%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="扇贝口语" scheme="http://zymdragonggg.github.io/tags/%E6%89%87%E8%B4%9D%E5%8F%A3%E8%AF%AD/"/>
    
      <category term="开言英语" scheme="http://zymdragonggg.github.io/tags/%E5%BC%80%E8%A8%80%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>如何做竞品分析（简介）</title>
    <link href="http://zymdragonggg.github.io/2020/04/12/jingpinfenxijieshao/"/>
    <id>http://zymdragonggg.github.io/2020/04/12/jingpinfenxijieshao/</id>
    <published>2020-04-12T04:43:21.000Z</published>
    <updated>2020-04-12T08:54:41.123Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍如何做好竞品分析。</p><p>由于还是产品小白，所以看了很多竞品分析的教程步骤以及竞品分析报告，最后基于自己的理解做了这样一份如何做好竞品分析的简介。</p><a id="more"></a><blockquote><p>竞品分析主要是通过对竞争对手的产品进行比较分析，了解竞争对手的产品功能、定位、策略以及市场动态，根据自己的需求选择竞品分析的重点，知己知彼，找出差异化，方便梳理自己产品的思路。</p></blockquote><p>本文内容主要参考了 <a href="http://www.woshipm.com/evaluating/332122.html" target="_blank" rel="noopener">板栗在飞</a> 对于竞品分析的介绍，主要是从用户、功能和数据分析的角度去做竞品分析。不过个人在竞品分析一节中加入了其他相关内容，认为这些也是竞品分析的一些需要重点考虑的事情。</p><h2 id="1-明确竞品分析的目的"><a href="#1-明确竞品分析的目的" class="headerlink" title="1. 明确竞品分析的目的"></a>1. 明确竞品分析的目的</h2><ul><li>为了谁而做，产品团队、研发设计还是运营、老板</li><li>着重分析哪些内容</li><li>这个报告能给谁带来什么有价值的结论和建议</li></ul><h2 id="2-选择合适的竞品"><a href="#2-选择合适的竞品" class="headerlink" title="2. 选择合适的竞品"></a>2. 选择合适的竞品</h2><ul><li>核心目标用户都是同一群体（但是满足的需求不同）的产品，有些产品是互补的</li><li>满足的都是同样的需求的产品（直接的竞争对手）</li><li>其他的产品（未来潜在的对手）</li></ul><h2 id="3-资料搜集"><a href="#3-资料搜集" class="headerlink" title="3. 资料搜集"></a>3. 资料搜集</h2><h3 id="a-搜集分析用户意见"><a href="#a-搜集分析用户意见" class="headerlink" title="a.搜集分析用户意见"></a>a.搜集分析用户意见</h3><p>(我们的产品和竞品的用户对于产品的看法和意见）</p><ul><li>分析角度<ul><li>如何看待我们和竞品都有的功能，他们是如何比较这个功能的</li><li>我们没有的功能但是竞品却有的功能，他们又是如何看待这个功能的，用户会不会因为这个功能而选择用竞品而不是我们；</li><li>我们有的功能但是竞品没有的功能，他们又是如何看待这个功能的，这个功能能不能帮助我们从竞品那里抢夺用户。</li></ul></li><li>分析方法<ul><li>App Store, 知乎，应用软件社区，产品行业网站，微博评论</li><li>从同事、朋友家人讨论</li><li>用户访谈</li><li>熟悉竞品，咨询对方，加入论坛甚至群，发现收集有价值的信息</li></ul></li></ul><h3 id="b-搜集并分析竞品的数据"><a href="#b-搜集并分析竞品的数据" class="headerlink" title="b. 搜集并分析竞品的数据"></a>b. 搜集并分析竞品的数据</h3><ul><li>获得哪些数据<ul><li>我们与竞品的市场份额占有比，下载量对比</li><li>与竞品用户数量对比，用户增长率，增长趋势，活跃度对比</li><li>其他数据</li></ul></li><li>获得方法<ul><li>百度指数、淘宝指数、友盟指数</li><li>艾瑞咨询、易观智库，CNNIC，比达咨询，DCCI互联网数据中心，Alexa;</li><li>App store，app annie；</li><li>其他</li></ul></li></ul><h2 id="3-竞品分析"><a href="#3-竞品分析" class="headerlink" title="3. 竞品分析"></a>3. 竞品分析</h2><p>竞品分析的三个方面，分析过程中应该围绕用户体验5要素：<strong>战略层、范围层、结构层、框架层、表现层。</strong></p><p>展开一下对用户体验5要素的解释：</p><p><em>这里内容借鉴<a href="http://www.woshipm.com/discuss/53005.html" target="_blank" rel="noopener">漓江</a>对于用户体验五要素的介绍</em></p><ul><li><strong>战略层：</strong>产品目标及目标用户（做什么、为谁而做？）</li><li><strong>范围层：</strong>功能及其内容需求整合（需要做哪些？）战略决定范围，功能承载产品价值，范围层是为了实现战略层。</li><li><strong>结构层：</strong>交互设计及其信息架构（怎么做？）结构层将从范围转变成如何响应用户的请求，确定各个将要呈现给用户的选项的模式和顺序：交互设计、信息架构</li><li><strong>框架层：</strong>界面设计（确定框架，按钮、输入框）、导航设计（呈现信息）和内容信息设计（信息沟通）（要做成什么样子）</li><li><strong>表现层：</strong>功能及内容的视觉呈现（做成了什么样子）</li></ul><h3 id="a-用户分析"><a href="#a-用户分析" class="headerlink" title="a. 用户分析"></a>a. 用户分析</h3><ul><li><p>核心用户</p><p>即最忠诚、粘性最高的用户</p></li><li><p>主流用户</p><p>用户构成比例</p></li></ul><h3 id="b-功能分析"><a href="#b-功能分析" class="headerlink" title="b. 功能分析"></a>b. 功能分析</h3><ul><li>核心竞争力</li><li>主要功能<ul><li>直接在产品内部看，根据用户的行为表现和反馈评价，判断功能好坏</li><li>在用户发表意见的地方去搜索：百度，微博，知乎，app store</li><li>主要功能选择：自己没有或者不太好的，对手做的好的来进行研究</li></ul></li></ul><h3 id="c-数据分析"><a href="#c-数据分析" class="headerlink" title="c. 数据分析"></a>c. 数据分析</h3><p>可以利用一些数据分析工具，查看排名以及变化趋势等</p><p>首先需要对整个领域进行一定的认知，了解这个领域的用户规模是什么样的</p><ul><li><p>整体数据</p><p>不同产品的排名、评价、差评</p></li><li><p>变化趋势</p><p>排名变化趋势等</p></li><li><p>具体功能数据</p><p>某项功能的数据对比</p></li></ul><h3 id="d-分析方法"><a href="#d-分析方法" class="headerlink" title="d.分析方法"></a>d.分析方法</h3><ul><li>十字交叉法</li><li>SWOT分析法<ul><li>S（strengths）是优势、W（weaknesses）是劣势，O（opportunities）是机会、T（threats）是威胁。</li><li>即基于内外部竞争环境和竞争条件下的态势分析，就是将与研究对象密切相关的各种主要内部优势、劣势和外部的机会和威胁等，通过调查列举出来，并依照矩阵形式排列，然后用系统分析的思想，把各种因素相互匹配起来加以分析，从中得出一系列相应的结论，而结论通常带有一定的决策性。</li></ul></li><li>信息对比<ul><li>目标用户</li><li>UI和UE</li><li>盈利模式</li><li>活动运营</li><li>核心功能<ul><li>功能的有无</li><li>功能的实现差别</li><li>用户满足的期望值</li></ul></li></ul></li></ul><h2 id="4-竞品分析结论"><a href="#4-竞品分析结论" class="headerlink" title="4. 竞品分析结论"></a>4. 竞品分析结论</h2><p>根据竞品分析，给出应该怎么做以达到竞品分析的目的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍如何做好竞品分析。&lt;/p&gt;
&lt;p&gt;由于还是产品小白，所以看了很多竞品分析的教程步骤以及竞品分析报告，最后基于自己的理解做了这样一份如何做好竞品分析的简介。&lt;/p&gt;
    
    </summary>
    
    
      <category term="产品知识" scheme="http://zymdragonggg.github.io/categories/%E4%BA%A7%E5%93%81%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="产品" scheme="http://zymdragonggg.github.io/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="竞品分析" scheme="http://zymdragonggg.github.io/tags/%E7%AB%9E%E5%93%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>NexT主题升级以及hexo4.2.0 NexT7.7.2主题美化</title>
    <link href="http://zymdragonggg.github.io/2020/03/29/hexotheme/"/>
    <id>http://zymdragonggg.github.io/2020/03/29/hexotheme/</id>
    <published>2020-03-29T14:55:32.000Z</published>
    <updated>2020-03-30T02:35:08.787Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍对NexT主题升级更新以及如何对NexT7.7.2版本的一些主题美化操作</p><a id="more"></a><h1 id="一、NexT主题升级"><a href="#一、NexT主题升级" class="headerlink" title="一、NexT主题升级"></a>一、NexT主题升级</h1><p>我觉得太痛苦了，原来用的NexT5.1.x版本，发现很多网上的东西不能用，然后就在<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/UPDATE-FROM-5.1.X.md" target="_blank" rel="noopener">从v5.1.x升级</a>这个介绍进行了升级，直接升级到v7。</p><ol><li><p>在blog根目录下输入：</p><p><code>git clone https://github.com/theme-next/hexo-theme-next themes/next-reloaded</code></p><p>这个指令下载最新的v7.7.2版本（今天是2020.3.29）到名字为<code>next-reloaded</code>的文件中</p></li><li><p>然后在修改站点配置文件：</p><p><code>theme: next-reloaded</code></p><p>这一版本需要注意，中文由原来的<code>zh-Hans</code>变成了<code>zh-CN</code></p></li><li><p>最后 <code>hexo s --debug</code> </p><p>就是全新版本了，很多东西需要重新配置了，尤其是原来<code>/next/source/css/</code>这个文件下很多东西都没了已经没有了,似乎都是统一到根目录下的source中了，我也没有太搞清楚。下文有实际案例具体介绍。</p></li></ol><h1 id="二、主题优化"><a href="#二、主题优化" class="headerlink" title="二、主题优化"></a>二、主题优化</h1><p><strong>说在前面：v7.7.2版本的很多东西都集成好了，可以直接在<code>_config.yml</code>进行true/false选择即可，只要仔细读读每一项的注释，很快就能配置好了。</strong></p><p><strong>下面一部分有关主题优化的是我觉得我读注释不太能理解的，以及注释没有提到的，当然后续可能也会更新一些新的主题优化相关的内容</strong></p><h2 id="1-查看Hexo博客NexT版本"><a href="#1-查看Hexo博客NexT版本" class="headerlink" title="1. 查看Hexo博客NexT版本"></a>1. 查看Hexo博客NexT版本</h2><p>在主题文件中找到package.json可以看到</p><h2 id="2-给文章添加阴影效果"><a href="#2-给文章添加阴影效果" class="headerlink" title="2.给文章添加阴影效果"></a>2.给文章添加阴影效果</h2><p>首先主题配置文件取消如下代码的注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style: source&#x2F;_data&#x2F;styles.styl</span><br></pre></td></tr></table></figure><p>在 blog/source/_data下创建 styles.styl文件，_data文件也是我手动创建的，在styles.styl文件中添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主页文章添加阴影效果</span><br><span class="line">.post &#123;</span><br><span class="line">   margin-top: 60px;</span><br><span class="line">   margin-bottom: 60px;</span><br><span class="line">   padding: 25px;</span><br><span class="line">   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是目前来看只有阅读文章的时候会出现阴影效果不知道为什么主页没有这个效果</p><h2 id="3-给文章添加-本文结束-标记"><a href="#3-给文章添加-本文结束-标记" class="headerlink" title="3. 给文章添加  本文结束  标记"></a>3. 给文章添加  本文结束  标记</h2><p>首先主题配置文件取消如下代码的注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postBodyEnd: source&#x2F;_data&#x2F;post-body-end.swig</span><br></pre></td></tr></table></figure><p>在 blog/source/_data下创建post-body-end.swig文件，（_data文件也是我手动创建的）在post-body-end.swig文件中添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style&#x3D;&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class&#x3D;&quot;fa fa-hand-peace-o&quot;&gt;&lt;&#x2F;i&gt;感谢您的阅读-------------&lt;&#x2F;div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>效果如图：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb57yb040j30j301cweh.jpg" alt="image-20200329215844684"></p><h2 id="4-阅读全文按钮颜色设置"><a href="#4-阅读全文按钮颜色设置" class="headerlink" title="4. 阅读全文按钮颜色设置"></a>4. 阅读全文按钮颜色设置</h2><p>首先主题配置文件取消如下代码的注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable: source&#x2F;_data&#x2F;variables.styl</span><br></pre></td></tr></table></figure><p>在 blog/source/_data下创建variables.styl文件，（_data文件也是我手动创建的）在variables.styl文件中添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Buttons</span><br><span class="line">&#x2F;&#x2F; --------------------------------------------------</span><br><span class="line">$btn-default-bg                 &#x3D; white;</span><br><span class="line">$btn-default-color              &#x3D; #006762;</span><br><span class="line">$btn-default-font-size          &#x3D; $font-size-small;</span><br><span class="line">$btn-default-border-width       &#x3D; 2px;</span><br><span class="line">$btn-default-border-color       &#x3D; #006762;</span><br><span class="line">$btn-default-hover-bg           &#x3D; #456f95;</span><br><span class="line">$btn-default-hover-color        &#x3D; white;</span><br><span class="line">$btn-default-hover-border-color &#x3D; #456f95;</span><br></pre></td></tr></table></figure><p>效果如图：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdb5t0xadwj30dk02t74h.jpg" alt="image-20200329221901928"></p><h2 id="5-如何添加文章版权"><a href="#5-如何添加文章版权" class="headerlink" title="5. 如何添加文章版权"></a>5. 如何添加文章版权</h2><p>在主题配置文件找到creative_commons, 设置post为true，其中sidebar根据自己喜好选择</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: true</span><br><span class="line">  post: true</span><br><span class="line">  language:</span><br></pre></td></tr></table></figure><h2 id="6-文章目录不自动编号"><a href="#6-文章目录不自动编号" class="headerlink" title="6.文章目录不自动编号"></a>6.文章目录不自动编号</h2><p>在主题配置文件中找到toc并设置number属性为false</p><h2 id="7-网页底部的动态桃心图像"><a href="#7-网页底部的动态桃心图像" class="headerlink" title="7. 网页底部的动态桃心图像"></a>7. 网页底部的动态桃心图像</h2><p>在主题配置文件中找到下面内容，设置其中animated为true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">icon:</span><br><span class="line"> name: user</span><br><span class="line">    animated: true</span><br><span class="line">   color: &quot;#006762&quot;</span><br></pre></td></tr></table></figure><p>效果就是扑通扑通的跳动心脏</p><hr><p>以后再有什么配置的再说吧。今天到此结束啦，累死了，搞了大半天，太痛苦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍对NexT主题升级更新以及如何对NexT7.7.2版本的一些主题美化操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础应用" scheme="http://zymdragonggg.github.io/categories/%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="Hexo" scheme="http://zymdragonggg.github.io/tags/Hexo/"/>
    
      <category term="NexT" scheme="http://zymdragonggg.github.io/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>vscode中有关git的警告：The git repository at XX has too many changes, only a subset of Git features will be enabled.</title>
    <link href="http://zymdragonggg.github.io/2020/03/29/git/"/>
    <id>http://zymdragonggg.github.io/2020/03/29/git/</id>
    <published>2020-03-29T03:23:14.000Z</published>
    <updated>2020-03-29T03:51:33.254Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍如何解决在用vscode时提示的一个和git相关的警告。</p><a id="more"></a><p>打开vscode时会提示：GIT: The git repository at XXX has too many active changes, only a subset of Git features will be enabled.</p><p>如图所示：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdan2tvha7j30ci030t91.jpg" alt="image-20200329113102051"></p><p>然后再侧边栏的source control在一段时间后会显示有5K的变化。如下图。（统计后蓝色的那个东西会显示5K）</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdanh95272j301r08vaa4.jpg" alt="image-20200329114456907"></p><p>统计这一过程非常慢。而且最近我的matlab运行非常的卡，最后干脆程序无响应。经过今天的研究认为应该就是在matlab路径下，很多数据变化了，git统计要很久，我认为这是主要原因。在查阅一些资料后，找到了一个最简单的解决方案：</p><p>找到提示中告知的文件路径，在里面打开显示隐藏文件（mac快捷键是command + shift + .），然后删除/Users/user_name/.git文件夹即可，如果需要对哪个仓库进行操作，只需要在特定文件夹下添加 .git文件即可。</p><p>删除下图文件夹。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdanbkxfdaj302p02rglm.jpg" alt="image-20200329113929726"></p><p>自从删除了这个文件夹，我的matlab终于顺畅了。。。。可是我不知道这是从什么时候开始出现的这个问题，我猜。。是我开始弄我这个个人博客开始吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍如何解决在用vscode时提示的一个和git相关的警告。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tips" scheme="http://zymdragonggg.github.io/categories/Tips/"/>
    
    
      <category term="git" scheme="http://zymdragonggg.github.io/tags/git/"/>
    
      <category term="vscode" scheme="http://zymdragonggg.github.io/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>如何保持ssh连接服务器时服务不断开</title>
    <link href="http://zymdragonggg.github.io/2020/03/26/ssh/"/>
    <id>http://zymdragonggg.github.io/2020/03/26/ssh/</id>
    <published>2020-03-26T11:21:28.000Z</published>
    <updated>2020-03-29T03:27:37.247Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍如何在ssh访问服务器时候不断开的一个简单操作。</p><a id="more"></a><p>疫情在家，有时候需要跑跑实验，自己的老mac跑太心疼，于是在之前<a href="https://zymdragonggg.github.io/2020/03/03/hexo_github/">配置阿里云服务器</a>上跑实验。</p><p>可是问题又来了，而且这个问题我在网上查发现是一个很常见的问题。</p><p><strong>当我们ssh连接上服务器后，连续操作都ok，可是当代码报错后，去找找bug，等在回来跑程序，就断了，还得重新ssh访问服务器，每次打开服务器还要cd目标文件、激活虚拟环境、在输入要运行的文件。</strong></p><p>呀好麻烦。。。</p><p>采访一下当事人：</p><blockquote><p>每次我都是眼疾手快，快速定位错误，赶紧跑回来运行看看还有问题吗。</p></blockquote><p>后来这也耐不住能力有限，还是得去找解决方案</p><p>但由于自己专业知识较薄弱，查阅了很多资料，很多相关的方法没有太懂，当时看到有需要编辑服务器配置文件的，自己尝试了发现还是不行。</p><p>最后经过筛选找到一个很好用的方法，安全又好用，只要我们在ssh访问服务器时用下面这个命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -o ServerAliveInterval&#x3D;60 user@sshserver</span><br></pre></td></tr></table></figure><p>这条指令的大致意思就是我访问服务器user@sshserver时，每60秒发送一个信号一类的东西，反正我理解就是不断保持服务器和客户端的数据沟通。</p><p>告诉服务器，我还在呢，你别不管我。</p><p>今天成功水了一篇文章，长篇大论下来，其实就一句话有用，不过我讲清楚了问题（需求），解决方案，最后满足了我们的期望。：）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍如何在ssh访问服务器时候不断开的一个简单操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tips" scheme="http://zymdragonggg.github.io/categories/Tips/"/>
    
    
      <category term="ssh" scheme="http://zymdragonggg.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>jupyter notebook配置过程中常见问题</title>
    <link href="http://zymdragonggg.github.io/2020/03/15/jupyter-notebook/"/>
    <id>http://zymdragonggg.github.io/2020/03/15/jupyter-notebook/</id>
    <published>2020-03-15T12:19:46.000Z</published>
    <updated>2020-03-15T12:47:31.050Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要针对在mac本上进行jupyter notebook配置时出现的一些小问题，提供解决方案以更好的帮助我们顺畅的使用jupyter。</p><a id="more"></a><h2 id="一、Mac-上对jupyter-notebook启动页面路径修改"><a href="#一、Mac-上对jupyter-notebook启动页面路径修改" class="headerlink" title="一、Mac 上对jupyter notebook启动页面路径修改"></a>一、Mac 上对jupyter notebook启动页面路径修改</h2><p>刚刚装好jupyter以后，进入启动页面会显示很多文件，那是因为没有修改默认启动路径。</p><p>进入terminal:</p><p><code>jupyter notebook --generate -config</code></p><p>然后会给出一个文件路径：<code>/Users/用户名/.jupyter/jupyter_notebook_config.py</code></p><p>复制这个路径<code>/Users/用户名/.jupyter/</code>，然后利用<strong>finder</strong>：前往—&gt;前往文件夹，找到<code>jupyter_notebook_config.py</code>，打开</p><p>找到下面的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 用于笔记本和内核的目录。</span></span><br><span class="line"><span class="comment">#c.NotebookApp.notebook_dir = ‘'</span></span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 用于笔记本和内核的目录。</span></span><br><span class="line">c.NotebookApp.notebook_dir = ‘自己想设的文件路径<span class="string">'</span></span><br></pre></td></tr></table></figure><p>一定要注意去掉 # 这个注释，然后填写一个文件路径来存放你的jupyter文件。</p><h2 id="二、在jupyter中切换conda虚拟环境"><a href="#二、在jupyter中切换conda虚拟环境" class="headerlink" title="二、在jupyter中切换conda虚拟环境"></a>二、在jupyter中切换conda虚拟环境</h2><p>Jupyter Notebook本身默认使用root目录下的Python环境的，如果想使用其它的虚拟环境，还需要通过nb_conda插件实现。</p><p>通过以下几步操作：</p><ol><li><p>安装插件</p><p><code>conda install nb_conda</code></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcuqdnlthgj30fu0c4q3i.jpg" alt="image-20200315171611913"></p><p>上图done以后就安装好了插件</p></li><li><p>在虚拟环境中安装jupyter</p><p>经过上一步操作，就可以进行环境切换了，但是还需要在我们配置的虚拟环境中也安装jupyter。由此，需要先进入环境再安装，最后再退出conda虚拟环境，如下三步操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda activate your_env_name</span><br><span class="line">conda install -y jupyter</span><br><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p>安装完毕后重启jupyter。新建一个文件，点击 服务—&gt;改变服务 (Kernel—&gt;Change kernel)就可以切虚拟环境了。如下图所示</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcuquu6ua2j30r809fjsr.jpg" alt="image-20200315173245233"></p><hr></li></ol><p><strong>安装过程中的错误：</strong></p><p>打开jupyter后点击主界面的conda弹出错误：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcuqjq9cx8j30iv03ogls.jpg" alt="image-20200315172204552"></p><p><strong>解决方法：</strong></p><p>在电脑中搜索envmanager.py文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="string">"environments"</span>: [root_env] + [get_info(env)</span><br><span class="line">                                    <span class="keyword">for</span> env <span class="keyword">in</span> info[<span class="string">'envs'</span>]]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#将上面这个内容替换为</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">       <span class="string">"environments"</span>: [root_env] + [get_info(env) <span class="keyword">for</span> env <span class="keyword">in</span> info[<span class="string">'envs'</span>] <span class="keyword">if</span> env != root_env[<span class="string">'dir'</span>]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后重启jupyter就可以了。</p><hr><p>本小节内容参考<a href="https://blog.csdn.net/it_xiao_bai/article/details/102765922" target="_blank" rel="noopener">IT_xiao_bai</a>的CSDN博客</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>jupyter配置过程中这是两个我最常遇到的问题，每次配置每次忘，终于把这些记录下来了，以后不用再去查查查了，可以自己翻笔记了！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要针对在mac本上进行jupyter notebook配置时出现的一些小问题，提供解决方案以更好的帮助我们顺畅的使用jupyter。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础应用" scheme="http://zymdragonggg.github.io/categories/%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="jupyter notebook" scheme="http://zymdragonggg.github.io/tags/jupyter-notebook/"/>
    
  </entry>
  
  <entry>
    <title>《人人都是产品经理》梳理</title>
    <link href="http://zymdragonggg.github.io/2020/03/13/renren/"/>
    <id>http://zymdragonggg.github.io/2020/03/13/renren/</id>
    <published>2020-03-13T10:50:23.000Z</published>
    <updated>2020-04-12T08:52:03.178Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对《人人都是产品经理》一书前5章的梳理，都是自己的理解和感悟，主要意图是帮助自己，也希望同样对产品感兴趣小白们看到这篇文章也能有所获。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcsldlc3ajj31ag0u0hdt.jpg" alt="XmindForrr"></p><a id="more"></a><p>最近在看一些产品相关的书籍。先是把《人人都是》简单过了一遍，虽然书中已经总结好了大致框架，不过为了自己更好的理解和记忆，我用Xmind做了思维导图帮助自己更好的理解。如上图所示。（可能看不清，不过兴许点大放大再放大应该也能看个差不多，嘻！）接下基于更好的理解书本内容以及方便查阅，要对这个图进行文字版的梳理同时加上一些自己的理解，可能理解不到位，自己也是在学习中，非常希望被指正。</p><p>OK，现在把上图捋直了看看。</p><h1 id="一、产品总述"><a href="#一、产品总述" class="headerlink" title="一、产品总述"></a>一、产品总述</h1><p>做产品之前需要先搞清楚三点认知</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><ul><li><p>所要做的产品是属于什么领域的，要什么不要什么，不能一口气想着做大，防止定位不清导致用户体验感差。</p></li><li><p>可以采用逆向思维来思考解决定位问题。</p></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p>面向的用户是谁？</p><ul><li>核心用户和非核心用户，需要优先考虑核心用户需求</li><li>客户（销售对象）：重视产品性价比（大人给孩子买玩具）</li><li>终端用户（使用者）：重视用户体验（孩子玩）</li></ul></li><li><p>需求是什么？</p><ul><li>直接的欲望（用户想要下班以后锻炼身体）</li><li>实际的愿望-目标（增强体魄，养成良好生活习惯）</li><li>人性 （希望得到他人称赞和敬佩的目光，使自己更有面子）</li></ul></li><li><p>应用场景是什么？</p><ul><li>时间：白天、中午、傍晚</li><li>地点：公司里、地铁上、家里</li></ul><p><em>特别值得注意的是，随着5G时代的到来以及各种移动智能设备的快速发展，应用场景变得越来越复杂，需要考虑的越来越细，（比如可能需要考虑当用户蹲厕所时的场景。。。）</em></p><p><strong><em>移动时代</em></strong>：<em>用户多样性、场景多样化、需求多样化</em></p><p><em>面对MOBILE，想要做出好的产品，就需要学习了解各种移动设备的知识（硬件、互动方式、产业链结构、应用逻辑…），<strong>总之就是你了解越清楚越有利于高效做一个更适合移动设备并且满足用户需求的好产品！</strong></em></p></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>解决用户的需求，往常通常采用线上的方法，但是现在的产品需要<strong><em>线上</em></strong>和<strong><em>线下</em></strong>的结合才能带来更好的效果。比如：</p><center>外卖</center><p>通过线上买家和卖家的共同参与，加上外卖小哥的爱心餐饮的传递，终于满足了因为忙（lan）而不自己做饭或出去吃饭的广大人民群众的需求。</p><h1 id="二、产品分类"><a href="#二、产品分类" class="headerlink" title="二、产品分类"></a>二、产品分类</h1><p>这一章主要是从不同角度对产品进行分类，没有绝对的某个产品一定属于某一类。</p><h2 id="用户关系"><a href="#用户关系" class="headerlink" title="用户关系"></a>用户关系</h2><ul><li><strong>单点</strong>：一个用户（计算器）</li><li><strong>单边</strong>：一群用户 （电话，用户之间有关联，形成一个网）</li><li><strong>多边</strong>：几群人- 平台（外卖，淘宝）</li></ul><h2 id="用户需求"><a href="#用户需求" class="headerlink" title="用户需求"></a>用户需求</h2><p>根据用户需求，可以分为：工具、内容、社交、交易、平台、游戏。</p><p>其中对于工具，流量多，可以理解为使用的人很多，但是粘不住用户（需要建立用户和工具之间的关系）。比如：查看天气的工具，或许大家根本不会在乎自己用什么产品去查看。</p><h2 id="用户类型"><a href="#用户类型" class="headerlink" title="用户类型"></a>用户类型</h2><ul><li><strong>2B</strong>：面向集体，具备商业价值，理解为生产资料，后台<ul><li>B2D，云存储、大数据等开发者服务，帮助开发者提升效率的基础设施</li><li>SaaS1.0，通用管理型SaaS(Software-as-a-Serivce,通过网络提供软件服务)，传统意义上的管理软件</li><li>B2B，垂直行业交易平台，是信息撮合+在线成交。</li><li>SaaS2.0，垂直行业SaaS工具+交易，是SaaS1.0和B2B的综合</li></ul></li><li><strong>2C</strong>：面向个人，注重用户体验，理解为生活资料，前台</li></ul><h2 id="产品形态"><a href="#产品形态" class="headerlink" title="产品形态"></a>产品形态</h2><ul><li><strong>BS结构</strong>（browser server）：轻量级，制作快，迭代周期短，试错成本低，质量要求不那么高</li><li><strong>CS结构</strong>（client server）：基本和BS相反</li><li><strong>软硬结合</strong>（软件+硬件） 【Apple Watch】</li><li><strong>大实体</strong>（软件+硬件+服务）【汽车】-&gt;不知道这个例子算不…</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他太多了，我记不住，写下来估计也用不太上，主要按照上面几种分类我觉得就够了。</p><h1 id="三、产品概念提出"><a href="#三、产品概念提出" class="headerlink" title="三、产品概念提出"></a>三、产品概念提出</h1><p>接下来我们开始定义我们产品的概念</p><h2 id="核心用户"><a href="#核心用户" class="headerlink" title="核心用户"></a>核心用户</h2><p>首先需要确立核心用户，核心用户定义越精准，产品效应越有力。</p><p>有相同价值观的人凝聚在一起，就加强了产品黏性。</p><p><em>这里就需要了解到对<strong>用户的分类</strong>：不同角色（多边类型的产品）； 新手、中间用户、专家；根据业务场景分类；根据统计的个人信息分类（慎用）</em></p><h2 id="刚性需求"><a href="#刚性需求" class="headerlink" title="刚性需求"></a>刚性需求</h2><p>我们的产品需要涉及什么样的需求可以根据以下三个要素来分析：</p><ul><li><strong>真实</strong>：需求是否切实</li><li><strong>刚需</strong>：需求强烈程度</li><li><strong>高频</strong></li></ul><p><em>需求不要被用户牵鼻子走，因为有时候用户提出的需求，可能是不现实、不必要、不常发生的。</em></p><h2 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h2><p>确立一个典型场景也格外重要。</p><p>书中说到一句话，我觉得很好，</p><center>“做产品就是做场景，应有自己产品的唤起点”</center><p>直接理解就是用户第一个想到的就是你，这样你做的产品才会是一个成功产品。</p><h2 id="产品概念"><a href="#产品概念" class="headerlink" title="产品概念"></a>产品概念</h2><p>基于上述几步，我们差不多可以提出产品的概念了，即</p><center>为解决什么人的什么需求，做的什么东西 </center><h2 id="竞争优势"><a href="#竞争优势" class="headerlink" title="竞争优势"></a>竞争优势</h2><p>设计了产品需要说出为什么你这个产品好，即具有什么竞争优势。</p><p><strong>竞争标的</strong>：人无我有，人有我优（多快好省）</p><p>进行竞争优势分析的时候可以囊括为以下这句话：</p><center>干什么而不怎么因为有什么样优点，能达到什么目的 </center><h1 id="四、产品概念筛选"><a href="#四、产品概念筛选" class="headerlink" title="四、产品概念筛选"></a>四、产品概念筛选</h1><p>定义好了的产品概念较广，我们需要根据内部和外部因素来进行筛选最适合的一个产品概念</p><h2 id="内部"><a href="#内部" class="headerlink" title="内部"></a>内部</h2><p>首先要力所能及，其次是大家伙一起乐意。</p><ul><li><strong>能力</strong> —— 人、财、物</li><li><strong>意愿</strong></li></ul><h2 id="外部"><a href="#外部" class="headerlink" title="外部"></a>外部</h2><ul><li><p>价值（产品能够发展到什么程度）</p><ul><li><p>宏观：发展到潜在用户，产品达到行业天花板</p></li><li><p>微观：种子用户，产品涉及到身边人</p></li></ul><p>这里需要介绍一些名词：</p><p><strong>种子用户（最早接触产品的人）—&gt; 核心用户（最重要的群体） —&gt; 目标用户（能和产品发生关系） —&gt; 潜在用户（将来的想象空间与发展天花板）</strong></p></li><li><p>成本和风险（制作的成本和风险）</p><ul><li><p>宏观：大环境下顺势而为（当前的政治、经济、社会、技术、环境、法律因素）</p></li><li><p>微观：行业环境 —&gt; 波特力五模型</p><ul><li>产业内部竞争者: 市场成熟度和竞争激烈程度</li><li>潜在进入者：行业门槛高低</li><li>替代品：替代能力</li><li>买方：设法分摊风险</li><li>卖方：避免过集中</li></ul></li></ul></li></ul><h1 id="五、需求采集"><a href="#五、需求采集" class="headerlink" title="五、需求采集"></a>五、需求采集</h1><p>这一章是《人人》第四章，其实我觉得这和产品概念应该并行的工作。</p><p>首先，两种采集方式</p><ul><li><strong>直接采集</strong>：自己亲自调查，更准确</li><li><strong>间接采集</strong>：通过数据分析，效率高</li></ul><p>从另一维度理解需求采集</p><ul><li>说(观点) —&gt; 做(行为)</li><li>定性(了解，个体研究) —&gt;定量(证实，群体)</li></ul><p><strong>从说到做，从做到说，从定性到定量，从定量到定性，螺旋式（用户访谈 -&gt; 调查问卷 -&gt; 可用性测试 -&gt; 数据分析 -&gt; 继续去访谈….）</strong></p><ul><li><p>应用场景是否真实：即采集时候是否在真实场景中进行的采集</p></li><li><p>用户是否与产品发生交互：用户有没有用过，是否只是用户想象的需求</p><ul><li>电视机需求：买了其实不怎么用</li><li>洗碗机需求：以为没啥用，其实用处很多</li></ul><p>解决这一问题，可以低成本验证，免费使用，试用产品。</p></li></ul><h1 id="六、用户研究"><a href="#六、用户研究" class="headerlink" title="六、用户研究"></a>六、用户研究</h1><p>采集好了需求，我们就需要对需求进行分析，去研究用户的观点和行为，找到用户的目的和动机，最后挖掘人性和价值观，从而才能做出更好的产品。我们可以利用马斯洛需求或者是与之相对应的弗洛伊德本我、自我、超我的理论来研究。</p><p><em>知识点补充：马斯洛需求</em></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcsq2cu870j30p00krmym.jpg" alt="马斯洛需求"></p><p><strong>分析用户的过程其实就是一个从抽象到具体再抽象———用户画像</strong></p><p><em>这里在补充一下：</em></p><p><em>- 用户描述就是产品需要解决的问题</em></p><p><em>-用户任务就是产品需要提供的解决方案</em></p><h1 id="七、需求分析Y模型"><a href="#七、需求分析Y模型" class="headerlink" title="七、需求分析Y模型"></a>七、需求分析Y模型</h1><p><strong>产品</strong>：<strong><em>从问题到方法的转化，从用户需求到产品功能的转换</em></strong></p><p>总结出来这个Y就是：</p><p><strong>用户需求</strong> ——&gt; <strong>用户目的</strong> ——&gt;(—&gt;<em>人性本质，马斯洛需求</em>)——&gt;<strong>产品功能</strong></p><p><em>把用户目的深挖，就是人性本质。根据用户目的找到产品的目的，就可以做出产品功能。</em></p><p><strong>总结两点制作Y模型需要注意的是：</strong></p><p><strong>从浅到深</strong>：当挖掘人性本质或者用户目的的时候可以采用攀梯术，询问用户为什么这样重要，这样意味着什么（情景代入、重复确认鼓励、时间倒流对比、需求缺失对比）</p><p><strong>从深到浅</strong>：功能越简单越好，简单留给用户，复杂留给产品经理</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>这次的知识分享到此结束，加上中间休息的时间，花费了我差不多2个小时的时间写这个博客。说实话一点也米有觉得浪费时间，反而又重温一遍这些知识点，加深了理解。</p><p>最后致谢过去的自己，感谢自己认真做了思维导图，让我可以在这么短的时间内把《人人》这本书的基础内容过一遍。</p><p>学习的路任重道远</p><blockquote><p>Stay hungry.  Stay foolish</p></blockquote><p>またね！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对《人人都是产品经理》一书前5章的梳理，都是自己的理解和感悟，主要意图是帮助自己，也希望同样对产品感兴趣小白们看到这篇文章也能有所获。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTly1gcsldlc3ajj31ag0u0hdt.jpg&quot; alt=&quot;XmindForrr&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="产品知识" scheme="http://zymdragonggg.github.io/categories/%E4%BA%A7%E5%93%81%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="产品" scheme="http://zymdragonggg.github.io/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="人人都是产品经理" scheme="http://zymdragonggg.github.io/tags/%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown语法</title>
    <link href="http://zymdragonggg.github.io/2020/03/11/markdown/"/>
    <id>http://zymdragonggg.github.io/2020/03/11/markdown/</id>
    <published>2020-03-11T07:51:28.000Z</published>
    <updated>2020-04-10T09:09:48.885Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了有关Markdown的语法。</p><a id="more"></a><p>本文参考了大树哥的博客，他和我说自己从新写一遍多浪费时间，让我直接用他的，然后我还是改动并且添加了一些内容，好了所以这一篇也是我的原创内容了！</p><p>所有使用Markdown语法标记的符号后要加一个空格<code>Space</code></p><h1 id="一、-标题"><a href="#一、-标题" class="headerlink" title="一、 标题"></a>一、 标题</h1><p>使用<code>#</code>来设置标题级数,一个<code>#</code>则代表一级标题,字体大小最大</p><p><code>#</code> </p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p><code>##一级标题</code></p><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p><code>###二级标题</code></p><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p><code>####三级标题</code></p><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p><code>#####四级标题</code></p><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><p><code>######五级标题</code></p><h1 id="二、-列表"><a href="#二、-列表" class="headerlink" title="二、 列表"></a>二、 列表</h1><h2 id="1-无序列表"><a href="#1-无序列表" class="headerlink" title="1. 无序列表"></a>1. 无序列表</h2><p>使用<code>-</code>、<code>+</code>、<code>*</code>三个符号都可以</p><ul><li>使用<code>-</code></li></ul><ul><li>使用<code>+</code></li></ul><ul><li>使用<code>*</code></li></ul><p>如果在列表中想取消下一行的列表性质,需要按下退格<code>Backspace</code>删除列表前的圆点后,然后按<code>Shift</code>+<code>Tab</code>组合键来退回首位.</p><ul><li>一级列表<ul><li>二级列表<ul><li>三级列表<ul><li>四级列表</li></ul></li></ul></li></ul></li></ul><h2 id="2-有序列表"><a href="#2-有序列表" class="headerlink" title="2. 有序列表"></a>2. 有序列表</h2><p>数字加点加空格,如<code>1.[Space]</code>、<code>2.[Space]</code></p><p>需要往前挪动请按<code>Tab</code>键,往后挪动请按<code>Shift</code>+<code>Tab</code>组合键</p><ol><li>第一级</li><li>第二级<ol><li>第二级第一小节</li><li>第二级第二小节<ol><li>第二级第二小节第一小小节</li><li>第二级第二小节第二小小节</li></ol></li><li>第二级第三小节</li></ol></li><li>第三级</li></ol><h1 id="三、-字体"><a href="#三、-字体" class="headerlink" title="三、 字体"></a>三、 字体</h1><ul><li><p><em>斜体</em></p><p>用法:<code>*[内容]*</code>或<code>_[内容]_</code>,包含在两个<code>*</code>星号或两个<code>_</code>下划线中间的内容会倾斜</p><p><code>*Hello World*</code>:<em>Hello World</em></p><p><code>_Hello World_</code>:<em>Hello World</em></p></li><li><p><strong>加粗</strong></p><p>用法:<code>**[内容]**</code>,包含在四个<code>*</code>星号中间的内容会加粗</p><p><code>**Hello World**</code>:<strong>Hello World</strong></p></li><li><p><strong><em>斜体加粗</em></strong></p><p>用法:<code>***[内容]***</code>,包含在六个<code>*</code>星号中间的内容会加粗并斜体</p><p><code>***Hello World***</code>:<strong><em>Hello World</em></strong></p></li><li><p><del>删除线</del></p><p>用法:<code>~~[内容]~~</code>,包含在四个<code>~</code>波浪号中间的内容会添加删除线</p><p><code>~~Hello World~~</code>:<del>Hello World</del></p></li></ul><h1 id="四、-引用"><a href="#四、-引用" class="headerlink" title="四、 引用"></a>四、 引用</h1><p><code>&gt;</code>表示引用,与<code>#</code>用法相同</p><p><code>&gt;</code></p><blockquote><p>一级引用</p></blockquote><p><code>&gt;&gt;</code></p><blockquote><blockquote><p>二级引用</p></blockquote></blockquote><p><code>&gt;&gt;&gt;</code></p><blockquote><blockquote><blockquote><p>三级引用</p></blockquote></blockquote></blockquote><p>退格使用<code>Shift</code>+<code>Tab</code></p><h1 id="五、-分割线"><a href="#五、-分割线" class="headerlink" title="五、 分割线"></a>五、 分割线</h1><p>大于等于三个的<code>-</code>或<code>+</code>或<code>*</code></p><p><code>---</code></p><hr><p><code>+++</code></p><p>+++</p><p><code>***</code></p><hr><h1 id="六、-图片"><a href="#六、-图片" class="headerlink" title="六、 图片"></a>六、 图片</h1><p>语法:<code>![图片文字](图片地址 &quot;鼠标放置时显示的信息&quot;)</code></p><p>例子:</p><p><code>![Queen](https://tva1.sinaimg.cn/large/00831rSTly1gcq09ook07j308c05k74c.jpg ”Your Majesty”)</code></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcq09ook07j308c05k74c.jpg" alt="Queen" title="Your Majesty"></p><h1 id="七、-超链接"><a href="#七、-超链接" class="headerlink" title="七、 超链接"></a>七、 超链接</h1><p>语法:<code>[超链接名](超链接地址 &quot;鼠标放置时显示的信息&quot;)</code></p><p>例子:<code>[百度一下,你就知道](www.baidu.com &quot;我就是百度&quot;)</code></p><p><a href="https://www.baidu.com" target="_blank" rel="noopener" title="我就是百度">百度一下,你就知道</a></p><h1 id="八、-代码"><a href="#八、-代码" class="headerlink" title="八、 代码"></a>八、 代码</h1><h2 id="1-单行"><a href="#1-单行" class="headerlink" title="1. 单行"></a>1. 单行</h2><p>使用<code>&#96;</code>反引号包裹</p><h2 id="2-多行-代码块"><a href="#2-多行-代码块" class="headerlink" title="2.多行,代码块"></a>2.多行,代码块</h2><p>使用三个反引号包裹</p><p><code>&#96;&#96;&#96;</code></p><p>使用<code>&#96;&#96;&#96;</code>+编程语言可以打开代码编辑器</p><p>如 <code>&#96;&#96;&#96;</code>+python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">这是一个python语法的编译器</span><br></pre></td></tr></table></figure><h1 id="九、-表格"><a href="#九、-表格" class="headerlink" title="九、 表格"></a>九、 表格</h1><h2 id="1-表格生成"><a href="#1-表格生成" class="headerlink" title="1. 表格生成"></a>1. 表格生成</h2><p>每一行都使用<code>|</code>隔开，一定切记<code>|</code>必须是英文输入法下的，并且表格的语句上一行必须为空行，不然表格不生效。</p><p>第二行使用<code>:</code>设置对齐,两边都加表示文字居中,加在左边表示居左</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|标题1|标题2|标题3|</span><br><span class="line">|-|:-:|:-|</span><br><span class="line">|1|2|3|</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>标题1</th><th style="text-align:center">标题2</th><th style="text-align:left">标题3</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">2</td><td style="text-align:left">3</td></tr></tbody></table></div><h2 id="2-表格内换行"><a href="#2-表格内换行" class="headerlink" title="2.表格内换行"></a>2.表格内换行</h2><p>在想要换行的地方加入<code>&lt;br&gt;</code>后继续输入文字即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|标题1|标题2|标题3|</span><br><span class="line">|-|:-:|:-|</span><br><span class="line">|1|2&lt;br&gt;dfa456|3|</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>标题1</th><th style="text-align:center">标题2</th><th style="text-align:left">标题3</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">2<br>dfa456</td><td style="text-align:left">3</td></tr></tbody></table></div><h1 id="十、-流程图"><a href="#十、-流程图" class="headerlink" title="十、 流程图"></a>十、 流程图</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">​&#96;&#96;&#96;flow</span><br><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">op&#x3D;&gt;operation: My Operation</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?</span><br><span class="line">e&#x3D;&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><p>下面是例子展示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">op&#x3D;&gt;operation: My Operation</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?</span><br><span class="line">e&#x3D;&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><h1 id="十一、-补充一些小Tips"><a href="#十一、-补充一些小Tips" class="headerlink" title="十一、 补充一些小Tips"></a>十一、 补充一些小Tips</h1><p>补充一些我常用到的小tips</p><h2 id="Tip-1-不显示全文"><a href="#Tip-1-不显示全文" class="headerlink" title="Tip 1 不显示全文"></a><strong>Tip 1 不显示全文</strong></h2><p>写博客时候我们希望首页不显示全文，只显示部分信息或者只放一个图片就OK，那么我们只要加入下列语法即可。例子如下</p><hr><p>这里放简单介绍</p><p><code>&lt;!--more--&gt;</code></p><p>这里放正文内容</p><hr><h2 id="Tip-2-文字居中"><a href="#Tip-2-文字居中" class="headerlink" title="Tip 2 文字居中"></a><strong>Tip 2 文字居中</strong></h2><p>markdown似乎不支持居中，于是有一种类似html的操作，按照如下进行编写:</p><p>语法：<code>&lt;center&gt;需要居中的文字&lt;/center&gt;</code></p><p>例子：</p><p><code>&lt;center&gt;诶，我居中了&lt;/center&gt;</code></p><center>诶，我居中了</center><h2 id="Tip3-调整图片比例"><a href="#Tip3-调整图片比例" class="headerlink" title="Tip3 调整图片比例"></a><strong>Tip3 调整图片比例</strong></h2><p>这里也利用html操作。</p><p>语法如下，在最后加上style=”zoom:20%”，缩放至百分之20</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://bkimg.cdn.bcebos.com/pic/9a504fc2d5628535185967869aef76c6a6ef63d8?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5"</span> <span class="attr">alt</span>=<span class="string">"img"</span> <span class="attr">style</span>=<span class="string">"zoom:20%;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://bkimg.cdn.bcebos.com/pic/9a504fc2d5628535185967869aef76c6a6ef63d8?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5" alt="img" style="zoom:20%;" /></p><p>大小调整语法如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://bkimg.cdn.bcebos.com/pic/9a504fc2d5628535185967869aef76c6a6ef63d8?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5"</span> <span class="attr">alt</span>=<span class="string">"img"</span> <span class="attr">height</span>=<span class="string">"30"</span> <span class="attr">width</span> =<span class="string">"50"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://bkimg.cdn.bcebos.com/pic/9a504fc2d5628535185967869aef76c6a6ef63d8?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5" alt="img" height="30" width ="50" /></p><p><strong>Tip 4 选个好用的markdown编辑器</strong></p><p>其实，如果不常用一些语法，完全可以使用markdown文档编辑器自带的编辑功能，只要选中要操作的内容，再去选择相应功能，就可以完成上述很多事情了。</p><p>我的是mac本，用的是<a href="https://typora.io/" target="_blank" rel="noopener">Typora</a>，Simple, yet Powerful.</p><p>简单干净，很喜欢这个markdown编辑器。其支持OS X，Windows，Linux</p><p>给你一个截图简单感受一下。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcq0x94qi5j30dk0fiagu.jpg" alt="操作界面"></p><p>好了今天的推送萌下线啦，好好学习。がんばります！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了有关Markdown的语法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="语言技能" scheme="http://zymdragonggg.github.io/categories/%E8%AF%AD%E8%A8%80%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="markdown" scheme="http://zymdragonggg.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>ナルト 青春无悔</title>
    <link href="http://zymdragonggg.github.io/2020/03/11/naruto/"/>
    <id>http://zymdragonggg.github.io/2020/03/11/naruto/</id>
    <published>2020-03-11T02:52:31.000Z</published>
    <updated>2020-03-11T08:08:02.104Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcpxeqd6l5j30d6088aag.jpg" alt="th"></p><p>本文纯属个人点滴记录以及感悟。</p><a id="more"></a><center>"わたしわ渦巻きなると！"</center><hr><p>我想我真的很爱这个动漫。</p><p>先采访一下儿时残留在记忆里的我：</p><blockquote><p>“大概初中的时候看的火影吧，那时候火影还没完结，等我看到差不多400集左右的时候我没有在看了，忘记什么原因不在看了，可能是没完结，可能学业太忙了。唯一当时留下的印象的就是，最后怎么各种复活？看不懂了，觉得剧情很混乱，但是当时仍然觉得这是一个很有趣的动漫，可能从小就是喜欢看那种一个小弱鸡变成大英雄的片子。”</p></blockquote><p>时光荏苒，转眼2020年，我24岁了，昨天（2020.3.10）我终于看完了已经完结了好几年的火影。</p><blockquote><p>“再次重新观看，我感受到了不同的心情，怎么说呢，就是有些悲伤和不舍，真的有一种觉得自己老了的感觉，看的时候经常看的噗嗤噗嗤忍不住的想笑，悲伤的时候可以哭到抽泣不止的那种，看完最后一集的时候，一回想起第一集鸣人的样子就会觉得，呀，结束了。然后眼眶就回湿润。”</p></blockquote><p>我会想念木叶村的蓝天白云的悠闲美丽时光，村民和谐生活时候的样子</p><p>我会想念鸣人就是当初的毛头小孩时无拘无束的样子</p><p>我会想念佐助趴在哥哥肩膀一脸幸福</p><p>我会想念鼬最后温柔的告诉佐助，“不管你今后的路想怎么走，我都会一直深爱着你。”</p><p>我会想念自来也和鸣人在的那个温暖的日子里，他们在树荫下，他为鸣人买来的雪糕一起谈笑的画面</p><p>我会难过自来也走后，鸣人自己拿着两个雪糕，独自坐在椅子上，路灯下，那滴在地上的泪水</p><p>我会想念白和再不斩</p><p>我会怀念千代婆婆最后那个和蔼的微笑</p><p>我会想念大战结束，鸣人笑着告诉父亲，妈妈嘱咐的我都好好做到了</p><p>我会想念鸣人结婚的时候，鸣人微微侧过的脸庞结巴地对伊鲁卡老师说出请他来以父亲的身份出席婚礼</p><p>我会想好多…</p><hr><p>再次重新的观看，带给我了太多感动，小时候只是觉得火影不过是个动漫而已，可是大了再看，这已经不再是个普通的动漫了。随说网上有很多人吐槽火影烂尾，但是我觉得还好，我依然被感动到稀里糊涂的。剧情有些地方确实不尽人意，但是总体我还是十分喜爱的。</p><p>我个人比较喜欢看电影和美剧，因为从小学过画画，也喜欢看动漫，但我看过的动漫不算多，不过火影真的爱。今天写下这个博文，也是想记录抒发一下自己的情感，感觉自从看完整个火影以后，一直陷在某种说不出的情绪中，可能中了伊邪那美吧哈哈哈哈哈，我相信自己很快就可以走出这个术的！</p><p>这个动漫看完以后有很多让我感到遗憾的时候，就是，自来也没能参加鸣人婚礼，不知道为啥，我真的好爱这个角色。看动漫的时候弹幕一条条的说如果自来也在的话一定会说：</p><center>“臭小子，结婚快乐！”</center><p>泪目啊啊啊啊。</p><p>还有一个很让我喜欢的角色就是鼬了，鼬当之无愧太帅了！爱吃甜食的鼬吃了一辈子的苦。太让人心疼了。</p><p>这里面我还比较喜欢的一个角色就是鹿丸，我喜欢聪明的脑袋瓜子，鹿丸也很帅啊。</p><p>还有卡卡西，不过他漏全脸的时候我为啥没有觉得特帅？？？</p><p>我甚至还有点喜欢蛇叔，最后几集蛇叔真的有点可爱</p><p>还有啊。。。。。（太多了，我真的一列举感觉太多了，几乎所有角色我都很喜欢）</p><p>呀我的九喇嘛！忘了提一嘴这个傲娇小宠物。</p><blockquote><p>只是一碎碎念起来以后就又会陷入感伤中…</p></blockquote><p>曾经看到Sir曾说过</p><blockquote><p>15年啊，当初守在电视、电脑前的那些人，如今已经走入社会。</p><p>生活中是房子、车子、老婆孩子，再要全身心追一部动漫，难。</p><p>青春只有一次，这才叫人怀念。</p></blockquote><p><strong>青春无悔入火影</strong>，非常感谢火影，给我感受到了很多，虽然嘴遁实属太强，但是我愿意让自己去发光发热给社会、祖国乃至世界带来温暖。和平可能永远不会真正到来，但是我心里ナルト一直在。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcpzmz1cc1j30k00m7ju5.jpg" alt="59ee2e4a674d05802c7d1cd2ae4634d9_720w"></p><center>私はいつもあなたを愛し</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTly1gcpxeqd6l5j30d6088aag.jpg&quot; alt=&quot;th&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文纯属个人点滴记录以及感悟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活点滴" scheme="http://zymdragonggg.github.io/categories/%E7%94%9F%E6%B4%BB%E7%82%B9%E6%BB%B4/"/>
    
    
      <category term="动漫" scheme="http://zymdragonggg.github.io/tags/%E5%8A%A8%E6%BC%AB/"/>
    
  </entry>
  
  <entry>
    <title>给Ubuntu服务器配置tensorflow2.0</title>
    <link href="http://zymdragonggg.github.io/2020/03/07/aliyunsetting/"/>
    <id>http://zymdragonggg.github.io/2020/03/07/aliyunsetting/</id>
    <published>2020-03-07T13:28:17.000Z</published>
    <updated>2020-05-07T04:40:49.429Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍如何在各种服务器上配置tensorflow机器学习框架。</p><a id="more"></a><h1 id="安装conda">安装conda</h1><p>业余的我只知道<a href="https://www.anaconda.com/" target="_blank" rel="noopener">Conda</a>是一个很好的用来管理环境的工具，好了上专业点的解释：</p><p><em>conda类似于npm或maven的包管理工具，只是conda是针对于python的。可以安装minconda或anaconda进行安装，前者是简化版本，只包含conda和其依赖。如果安装环境有python相关包也没有关系，不需要进行卸载。anaconda支持windows、mac和linux系统，且有两个类型的版本，分别是GUI和command line版本，前者是图形界面，后者是命令行界面，占用资源较少。</em></p><p>那么我们在服务器上配置的时候其实用<strong>minconda</strong>就好了，废话不多少，开始上第一步。</p><p>在需要配置的服务器，依次输入下列命令</p><ul><li>下载miniconda</li></ul><p><code>wget https://repo.continuum.io/miniconda/Miniconda3-4.6.14-Linux-x86_64.sh</code></p><ul><li>安装miniconda</li></ul><p><code>sh Miniconda3-4.6.14-Linux-x86_64.sh</code></p><p>一路yes和 回车。</p><p>回到根目录</p><p><code>source ~/.bashrc</code></p><ul><li>更新conda</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda update conda</span><br><span class="line">conda update --all</span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure><p>至此conda安装完毕，接下来进入虚拟环境管理</p><h1 id="用conda配置虚拟环境">用Conda配置虚拟环境</h1><ul><li>创建 名字为your-name的，python版本为3.6的虚拟环境</li></ul><p><code>conda create -n your-name python=3.6 #这里可以自己根据自己需求选择</code></p><ul><li>打开虚拟环境</li></ul><p><code>conda activate your-name</code></p><ul><li>关闭虚拟环境</li></ul><p><code>conda deactivate</code></p><ul><li>安装需要用到的package</li></ul><p><code>conda install package-name</code></p><p>基于本文需求，我们这里安装tensorflow2.0这个package</p><p><code>conda install tensorflow</code></p><p>也可以指定tf的版本，不过默认的话目前会下载tf2.0。</p><p>通过以下指令可以查看已安装包</p><p><code>conda list</code></p><p>至于gpu版本的tensorflow因为我用不到，所以我没研究。。。。。。。。。。。。好，避免尴尬，下一步吧<sup>-</sup></p><h1 id="测试tf是否安装成功">测试tf是否安装成功</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;<span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">&gt;&gt;print(tf.\_\_version\_\_)  <span class="comment">#注意这里两个总共四个下划线</span></span><br><span class="line"><span class="number">2.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>Ok 啦，今天的小教程结束了！！！</p><p>其实这是我给自己用的要不然每次查太累了。加油！go go go!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍如何在各种服务器上配置tensorflow机器学习框架。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础应用" scheme="http://zymdragonggg.github.io/categories/%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="conda" scheme="http://zymdragonggg.github.io/tags/conda/"/>
    
      <category term="Tensorflow2.0" scheme="http://zymdragonggg.github.io/tags/Tensorflow2-0/"/>
    
  </entry>
  
</feed>
