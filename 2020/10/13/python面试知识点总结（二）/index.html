<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/dragon-apple.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/dragon-medium.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/dragon-small.png">
  <link rel="mask-icon" href="/images/dragon-logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=KaiTi,"Microsoft YaHei",Georgia:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zymdragonggg.github.io","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="秋招以来，为了找工作又学习了很多python相关的知识，给大家分享一下，里面好多内容都是我东拼西凑出来的（如果是借鉴了其他博客的，希望大家可以指出，我会标注上），感觉都是比较常见的或者被问到的。 希望这篇分享会对大家找工作有所帮助～">
<meta property="og:type" content="article">
<meta property="og:title" content="python面试知识点总结（二）">
<meta property="og:url" content="http://zymdragonggg.github.io/2020/10/13/python%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/index.html">
<meta property="og:site_name" content="ZYM&#39;Blog">
<meta property="og:description" content="秋招以来，为了找工作又学习了很多python相关的知识，给大家分享一下，里面好多内容都是我东拼西凑出来的（如果是借鉴了其他博客的，希望大家可以指出，我会标注上），感觉都是比较常见的或者被问到的。 希望这篇分享会对大家找工作有所帮助～">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/09/03/FAkYdj1mar5bliZ.png">
<meta property="og:image" content="https://i.loli.net/2020/09/03/a4uMQZg1Bycjh9s.png">
<meta property="og:image" content="https://i.loli.net/2020/08/26/CHdG9iS7r5heyBn.png">
<meta property="og:image" content="http://zymdragonggg.github.io/Users/m/Documents/Blog/source/_posts/C:/Users/M/AppData/Roaming/Typora/typora-user-images/image-20200806100010605.png">
<meta property="og:image" content="https://i.loli.net/2020/08/26/AausiXQr9hq4ot3.png">
<meta property="og:image" content="https://img-blog.csdn.net/20180122142356120?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmVpa29uMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://i.loli.net/2020/08/26/mEMZXS94Kv7qTBW.png">
<meta property="og:image" content="https://i.loli.net/2020/09/03/I8DlkJKPVAwjR9W.png">
<meta property="og:image" content="https://i.loli.net/2020/08/26/nfJUcdbuEFA1jW6.png">
<meta property="og:image" content="https://i.loli.net/2020/08/26/EyLGI6zfUqe38JT.png">
<meta property="og:image" content="https://i.loli.net/2020/08/26/lThZ967xImDbiaQ.png">
<meta property="og:image" content="https://i.loli.net/2020/08/26/rPMxhA56gbQBo2u.png">
<meta property="og:image" content="https://img-blog.csdn.net/20170516000644044?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamluaXhpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://i.loli.net/2020/08/26/UcwIlK8XBT6oOLu.png">
<meta property="og:image" content="https://i.loli.net/2020/09/05/hEDdqnaArXiIUgF.png">
<meta property="article:published_time" content="2020-10-13T11:27:13.000Z">
<meta property="article:modified_time" content="2020-10-13T12:11:37.761Z">
<meta property="article:author" content="Amanda Z">
<meta property="article:tag" content="python">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/09/03/FAkYdj1mar5bliZ.png">

<link rel="canonical" href="http://zymdragonggg.github.io/2020/10/13/python%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>python面试知识点总结（二） | ZYM'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="ZYM'Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ZYM'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">To learn, to be strong</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/zymdragonggg" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zymdragonggg.github.io/2020/10/13/python%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/dragon.png">
      <meta itemprop="name" content="Amanda Z">
      <meta itemprop="description" content="Don not look up to others. I am also a landscape :)">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYM'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          python面试知识点总结（二）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-13 19:27:13 / 修改时间：20:11:37" itemprop="dateCreated datePublished" datetime="2020-10-13T19:27:13+08:00">2020-10-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index"><span itemprop="name">python知识点</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/10/13/python%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/10/13/python%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    

    <div class="post-body" itemprop="articleBody">

      
        <p>秋招以来，为了找工作又学习了很多python相关的知识，给大家分享一下，里面好多内容都是我东拼西凑出来的（如果是借鉴了其他博客的，希望大家可以指出，我会标注上），感觉都是比较常见的或者被问到的。</p>
<p>希望这篇分享会对大家找工作有所帮助～</p>
<a id="more"></a>
<h2 id="gil及多线程相关">1. GIL及多线程相关</h2>
<ul>
<li><p><strong>背景概念：</strong></p>
<ul>
<li><strong>支持多线程：</strong>不同线程对共享资源访问的互斥</li>
<li><strong>多线程带来的问题：</strong>多线程是可以共享变量的，同时执行可能会导致数据被污染造成数据混乱，这是线程的不安全性，引入互斥锁。</li>
<li><strong>互斥锁：</strong>确保某段关键的代码数据只能有一个线程从头到尾完整执行，保证了这段代码数据的安全性，但是这也会导致死锁。</li>
<li><strong>死锁：</strong>多个子线程在等待对方解除占用状态，但是都不先解锁，互相等待，导致死锁。</li>
</ul></li>
<li><p><strong>python中的多线程</strong></p>
<ul>
<li><p><strong>GIL锁（Global Interpreter Lock）</strong>：为了利用多核，python开始支持多线程，解决多线程之间数据完整性和状态同步的最简单方法就是加锁，GIL是Python的全局解释器锁，GIL<strong>确保每次只能执行一个“线程”</strong>。一个线程获取GIL执行相关操作，然后将GIL传递到下一个线程。</p></li>
<li><p>虽然看起来程序被多线程并行执行，但它们实际上只是轮流使用相同的CPU核心。所有这些GIL传递都增加了执行的开销。<strong>这意味着多线程并不能让程序运行的更快。</strong></p></li>
<li><p>同一进程中如有多个线程运行，一个线程在运行时会霸占python解释器，加了一把锁即GIL，使该进程内的其他线程无法运行，等该线程运行完后其他线程才运行，如果线程运行过程中<em>遇到耗时的操作</em>（阻塞），则解释器锁解开，使其他线程运行，所以在多线程中，<strong>线程的运行仍然是有先后顺序的，并不是同时进行的</strong>。在同一时刻，只能有一个线程在一个cpu上执行字节码，没法像C和JAVA一样将多个线程映射到多个CPU上执行，但是GIL<strong>会根据执行的字节码行数和时间片以及遇到的IO操作的时候主动释放锁</strong>，让其他字节码进行。多线程爬取单线程性能有所提升，因为遇到IO操作阻塞会释放GIL锁，会在合适的时间转换到其他线程执行。</p></li>
<li><p><strong>基于GIL的存在，在遇到大量IO操作代码时，使用多线程效率更高。</strong></p></li>
<li><p>计算密集型（大量计算不停止一直算），用多进程</p></li>
<li><p>IO密集型（读写），用线程（利用等待的时间加速），<strong>协程也是适合io密集型</strong></p></li>
<li><p><strong>多线程怎么使用多核：</strong> 1、重写python编译器(官方cpython)如使用：PyPy解释器 2、调用C语言的链接库</p>
<blockquote>
<p>明确GIL不是Python的特性，是实现Python解析器（Cpython）时引入的一个概念，python的解析器还有Pypy、psyco等，大部分环境下默认是Python的执行环境。</p>
</blockquote></li>
</ul></li>
</ul>
<h2 id="python多线程多进程实践"><strong>2. python多线程、多进程实践</strong></h2>
<p>1）背景知识概念</p>
<ul>
<li><p><strong>多任务</strong>：同一时间执行多个任务，可以充分利用计算资源，提升执行效率</p>
<ul>
<li><p>多任务执行方式：</p>
<ul>
<li><strong>并发：</strong>在一段时间内<strong>交替</strong>（时间非常短）去执行多个任务，<strong>单核CPU处理多任务</strong>，操作系统轮流让各个任务交替的执行。<strong>任务数量大于CPU核心数</strong></li>
<li><strong>并行：</strong>在一段时间内<strong>真正的同时一起执行</strong>多个任务，<strong>多核CPU</strong>，操作系统给CPU的每一个内核安排一个执行的任务，多个内核一起同时执行任务，<strong>任务数量小于或者等于CPU核心数</strong></li>
</ul></li>
</ul></li>
</ul>
<p>2）在python中想要实现多任务，需要使用多进程来完成</p>
<ul>
<li>进程是操作系统资源分配（内存、磁盘、网络）的最小单位，是一个运行的程序，如正在运行的QQ、微信等。一个运行的程序至少有一个进程</li>
<li><p>没有多进程时候是只有一个主进程，多进程的时候是额外创建多个子进程</p></li>
<li><p><strong>python多进程实践</strong></p></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入包</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建进程对象</span></span><br><span class="line">进程对象 = multiprocessing.Process(target = 任务名字（函数名、方法名）)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Process还有两个属性： name,给进程指定一个名字，通常系统会自动给出名字，group，进程组，目前只能使用None。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动进程执行任务</span></span><br><span class="line">进程对象.start()</span><br></pre></td></tr></table></figure>
<ul>
<li><p>进程执行带有参数的任务</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        print(<span class="string">'i am singing'</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dance</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        print(<span class="string">'i am dancing'</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># args指定使用元组的方式给指定任务传参，按顺序传给任务传参，一定要和参数的顺序一致</span></span><br><span class="line">    <span class="comment"># kwargs指定字典的方式给指定任务传参，key就是参数的名字，必须严格一致。按照key的名字传参。</span></span><br><span class="line">    p1 = multiprocessing.Process(target = sing,args=(<span class="number">3</span>,));</span><br><span class="line">    p2 = multiprocessing.Process(target = dance,kwargs=&#123;<span class="string">'num'</span>:<span class="number">2</span>&#125;);</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br></pre></td></tr></table></figure></li>
<li><p>对进程的管理-获取进程编号</p>
<p><code>import os</code> 获取当前进程编号<code>pidos.getpid()</code>,获取当前进程父进程的编号<code>pidos.getppid()</code></p>
<p><img src="https://i.loli.net/2020/09/03/FAkYdj1mar5bliZ.png" /></p></li>
<li><p>守护主进程</p>
<p><em>主进程会等待所有的子进程执行结束再结束</em>，但是我们希望主进程结束，<strong>子进程也直接销毁，不再执行子进程中的代码</strong>，这就需要设置守护主进程：<code>子进程.daemon = True</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        print(<span class="string">'i am working'</span>)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = multiprocessing.Process(target = work, args=(<span class="number">20</span>,));</span><br><span class="line">    p.daemon = <span class="literal">True</span> <span class="comment"># 这个一定要放在start之前</span></span><br><span class="line">    p.start()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'work done!'</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>3）<strong>Python多线程</strong>：线程是程序执行的最小单位，共享同一个进程的资源，可以实现多任务。</p>
<ul>
<li><p>Python多线程实践：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入包</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建进程对象</span></span><br><span class="line">线程对象 = threading.Thread(target = 任务名字（函数名、方法名）)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Process还有两个属性： name,给线程指定一个名字，通常系统会自动给出名字，group，线程组，目前只能使用None。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动进程执行任务</span></span><br><span class="line">线程对象.start()</span><br></pre></td></tr></table></figure>
<p>整个都和多进程一样，可以试着去做一下线程执行带有参数的任务，和进程保持一致。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        print(<span class="string">'i am singing'</span>)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 下面是两种设置守护线程的方式</span></span><br><span class="line">    <span class="comment"># t = threading.Thread(target = sing,args=(10,), daemon=True);</span></span><br><span class="line">    t = threading.Thread(target = sing,args=(<span class="number">10</span>,));</span><br><span class="line">    t.setDaemon(<span class="literal">True</span>)</span><br><span class="line">    t.start()</span><br><span class="line">    </span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'well done!'</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>多线程之间的执行是无序的，是由CPU调度决定的、操作系统决定的。</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 让这个函数等待1秒在执行，相当于5个线程都创建好之后，一起等着开始执行后面的语句，会发现每次运行结果不相同</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 获取当前线程的线程对象</span></span><br><span class="line">    thread = threading.current_thread()</span><br><span class="line">    print(thread)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        sub_thread = threading.Thread(target=task)</span><br><span class="line">        sub_thread.start()</span><br></pre></td></tr></table></figure>
<p>4）关系对比</p>
<ul>
<li>线程依附在进程里面，没有进程就没有线程</li>
<li><p>一个进程默认提供一条线程，进程可以创建多个线程</p></li>
<li><p>区别对比</p>
<ul>
<li>创建进程的资源开销比创建线程的资源开销大</li>
<li>进程是操作系统资源分配的基本单位，线程是CPU调度的单位</li>
<li>线程不能独立运行，依附进程</li>
</ul></li>
<li><p>优缺点对比</p>
<ul>
<li>进程：开销大，可以利用多核</li>
<li>线程，开销小，不能用多核</li>
</ul></li>
</ul>
<p>首先，如果不做任何限制，主线程执行完，子线程再继续执行；如果加上守护进程，主线程执行完，子线程无法执行；利用Join()，主线程等子线程执行完毕再执行（join所完成的工作就是线程同步，即主线程任务结束之后，进入阻塞状态，一直等待其他的子线程执行结束之后，主线程在终止）</p>
<blockquote>
<p>join有一个timeout参数：</p>
<ol type="1">
<li>当设置守护线程时，含义是主线程对于子线程等待timeout的时间将会杀死该子线程，最后退出程序。所以说，如果有10个子线程，全部的等待时间就是每个timeout的累加和。简单的来说，就是给每个子线程一个timeout的时间，让他去执行，时间一到，不管任务有没有完成，直接杀死。</li>
<li>没有设置守护线程时，主线程将会等待timeout的累加和这样的一段时间，时间一到，主线程结束，但是并没有杀死子线程，子线程依然可以继续执行，直到子线程全部结束，程序退出。</li>
</ol>
</blockquote>
<p>5）pyton多进程、线程、协程，多进程怎么通信</p>
<ul>
<li><p>协程</p>
<p>线程是系统级别的，它们是由操作系统调度；协程是程序级别的，由程序员根据需要自己调度。我们把一个线程中的一个个函数叫做子程序，那么子程序在执行过程中可以中断去执行别的子程序；别的子程序也可以中断回来继续执行之前的子程序，这就是<strong>协程</strong>。也就是说同一线程下的一段代码&lt;1&gt;执行着执行着就可以中断，然后跳去执行另一段代码，当再次回来执行代码块&lt;1&gt;的时候，接着从之前中断的地方开始执行。</p>
<ul>
<li>yield实现协程</li>
<li>greenlet,手动切换</li>
<li>gevent实现协程：第三方库</li>
</ul></li>
<li><p>通信</p>
<ul>
<li>pip：适用于两个进程一个读一个写的单双工情况，信息是一个方向的流动 ，读写效率高于queue</li>
<li>queue：多个进程进行读或者多个进程进行写</li>
</ul>
<p>在一个进程中，不同子线程负责不同的任务，t1子线程负责获取到数据，t2子线程负责把数据保存的本地，那么<strong>他们之间的通信使用Queue来完成</strong>。因为再一个进程中，数据变量是共享的，即<strong>多个子线程可以对同一个全局变量进行操作修改</strong>，<strong>Queue是加了锁的安全消息队列</strong>。</p></li>
</ul>
<p>6）线程同步</p>
<p>如果没有控制多个线程对同一资源的访问，对数据造成破坏，使得线程运行的结果不可预期，这种现象称为“线程不安全”</p>
<p>同步的意思是：进程或线程A和B一块配合，A执行到1一定程度的时候要依靠B的某个结果，于是停下来，示意B运行；B运行后，再将结果传给A；A再继续操作。</p>
<ul>
<li><p>线程锁实现同步控制</p>
<p>线程锁使用threading.Lock()实例化，使用acquire()上锁，使用release()释放锁，acquire()和release()必须同时成对存在</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> l1.acquire():</span><br><span class="line">            <span class="comment"># 如果第一把锁上锁了</span></span><br><span class="line">            print(<span class="string">'我是老大，我先运行'</span>)</span><br><span class="line">            l2.release()</span><br><span class="line">            <span class="comment"># 释放第二把锁</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> l2.acquire():</span><br><span class="line">            <span class="comment"># 如果第二把锁上锁了</span></span><br><span class="line">            print(<span class="string">'我是老二，我第二运行'</span>)</span><br><span class="line">            l3.release()</span><br><span class="line">            <span class="comment"># 释放第三把锁</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run3</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> l3.acquire():</span><br><span class="line">            <span class="comment"># 如果第三把锁上锁了</span></span><br><span class="line">            print(<span class="string">'我是老三，我最后运行'</span>)</span><br><span class="line">            l1.release()</span><br><span class="line">            <span class="comment"># 释放第一把锁</span></span><br><span class="line">t1 = threading.Thread(target=run1)</span><br><span class="line">t2 = threading.Thread(target=run2)</span><br><span class="line">t3 = threading.Thread(target=run3)</span><br><span class="line"></span><br><span class="line">l1 = threading.Lock()</span><br><span class="line">l2 = threading.Lock()</span><br><span class="line">l3 = threading.Lock()</span><br><span class="line"><span class="comment"># 实例化三把锁</span></span><br><span class="line"></span><br><span class="line">l2.acquire()</span><br><span class="line">l3.acquire()</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t3.start()</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">我是老大，我先运行</span><br><span class="line">我是老二，我第二运行</span><br><span class="line">我是老三，我最后运行</span><br><span class="line">我是老大，我先运行</span><br><span class="line">我是老二，我第二运行</span><br><span class="line">我是老三，我最后运行</span><br><span class="line">我是老大，我先运行</span><br><span class="line">我是老二，我第二运行</span><br><span class="line">我是老三，我最后运行</span><br><span class="line">.....</span><br></pre></td></tr></table></figure></li>
<li><p>条件变量实现同步精准控制</p>
<p>信号量实现定量的线程同步</p>
<p>semaphore适用于控制进入数量的锁，好比文件的读写操作，写入的时候一般只用一个线程写，如果多个线程同时执行写入操作的时候，会造成写入数据混乱，读取的时候可以用多个线程读取，即写与写是互斥的，读与写不是互斥的，读与读不是互斥的。</p>
<p>BoundedSemaphore，这种锁允许一定数量的线程同时更改数据，不是互斥锁。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n, se)</span>:</span></span><br><span class="line">    se.acquire()</span><br><span class="line">    print(<span class="string">"run the thread: %s"</span> % n)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    se.release()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置允许5个线程同时运行</span></span><br><span class="line">semaphore = threading.BoundedSemaphore(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(i,semaphore))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<p>运行后，即5个一批的线程被放行，用来控制进入某段代码的线程数量</p></li>
</ul>
<h2 id="map函数和reduce函数">3. map函数和reduce函数</h2>
<p>map函数返回的是一个生成器。map函数的第一个参数是function,第二个参数一般是list，第三个参数可以是List，也可以不写。通过函数function依次作用在list上的每个元素，得到一个新的List返回。</p>
<p><img src="https://i.loli.net/2020/09/03/a4uMQZg1Bycjh9s.png" /></p>
<p>reduce函数的参数必须接受两个参数，reduce()函数将传入的函数作用在序列的第一个元素得到结果后，把这个结果继续与下一个元素作用（累积计算），最终结果是所有的元素相互作用的结果。</p>
<p><img src="https://i.loli.net/2020/08/26/CHdG9iS7r5heyBn.png" /></p>
<p><img src="/Users/m/Documents/Blog/source/_posts/C:\Users\M\AppData\Roaming\Typora\typora-user-images\image-20200806100010605.png" /></p>
<p><strong>map函数省去了for循环的过程，lambda省去了定义函数</strong></p>
<h2 id="python中断言">4. python中断言</h2>
<p>Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。</p>
<p>用来检查一个条件，如果为真，就不做任何事情，如果为假，提示<strong>assertionError异常信息</strong></p>
<p>断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况，例如我们的代码只能在 Linux 系统下运行，可以先判断当前系统是否符合条件。</p>
<p><img src="https://i.loli.net/2020/08/26/AausiXQr9hq4ot3.png" /></p>
<h2 id="python2和3的区别">5. Python2和3的区别</h2>
<ul>
<li>python3使用Print必须加小括号打印内容，python2既可以使用带小括号的方式，也可以使用一个空格来分隔打印内容</li>
<li>python2中的range是生成一个列表 range(3)--&gt;[0,1,2], xrange是一个生成器，python3中的range是一个可迭代对象，既不是生成器也不是迭代器</li>
<li>python2中使用ASCII编码，python使用UTF-8编码</li>
<li>python2中unicode表示字符串序列，str表示字节序列，python2中str表示字符串序列，byte表示字节序列</li>
<li>python2中为正常显示中文，引入coding声明,python3不需要</li>
<li>python2中是raw_input()，python3中是Input()函数</li>
<li>python2中除法是默认向下取整，为整型，python3是正常除法，为浮点型</li>
<li>python2中的字典使用开放地址法解决冲突，python3用的是链地址法</li>
</ul>
<h2 id="异常捕获和处理">6. 异常捕获和处理</h2>
<ul>
<li><p>常见异常</p>
<p>AttributeError 属性异常 比如foo.x，但是foo没有x属性</p>
<p>IOError 输入输出异常，基本上是无法打开文件</p>
<p>ImportError 无法引入模块或包；基本上是路径问题或名称错误 IndentationError 语法错误（的子类） ；代码没有正确对齐 IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5] KeyError 试图访问字典里不存在的键 KeyboardInterrupt Ctrl+C被按下 NameError 使用一个还未被赋予对象的变量 SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了） TypeError 传入对象类型与要求的不符合 UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，导致你以为正在访问它 ValueError 传入一个调用者不期望的值，即使值的类型是正确的</p></li>
<li><p>捕捉异常可以使用try/except语句。</p></li>
<li><p>try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">&lt;语句&gt;        <span class="comment">#运行别的代码</span></span><br><span class="line"><span class="keyword">except</span> &lt;名字&gt;：</span><br><span class="line">&lt;语句&gt;        <span class="comment">#如果在try部份引发了'name'异常</span></span><br><span class="line"><span class="keyword">except</span> &lt;名字&gt;，&lt;数据&gt;:</span><br><span class="line">&lt;语句&gt;        <span class="comment">#如果引发了'name'异常，获得附加的数据</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">&lt;语句&gt;        <span class="comment">#如果没有异常发生</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用except而不带任何异常类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    正常的操作</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    发生异常，执行这块代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    如果没有异常执行这块代码</span><br></pre></td></tr></table></figure>
<p><strong>以上方式try-except语句捕获所有发生的异常。但这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息。因为它捕获所有的异常。</strong></p></li>
<li><p>try-finally 语句</p>
<p>try-finally 语句无论是否发生异常都将执行最后的代码。</p></li>
<li><p>触发异常</p>
<p><code>raise</code>语句自己触发异常，触发以后不再执行后面的语句</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionName</span><span class="params">( level )</span>:</span></span><br><span class="line">    <span class="keyword">if</span> level &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"Invalid level!"</span>, level)</span><br><span class="line">        <span class="comment"># 触发异常后，后面的代码就不会再执行</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="提高python运行效率的方法">7. 提高python运行效率的方法</h2>
<ul>
<li><p>使用生成器，可以节约大量内存</p></li>
<li><p>循环代码优化，避免过多重复代码的执行</p></li>
<li><p>核心模块用Cpython PyPy等</p>
<blockquote>
<p>python没有专门机构负责实现，多个社区实现的。Cpython是C语言实现的Python，用java开发的JPython，Cpython使用解释执行的方式，性能差，但是PyPy是JIT(即时编译),性能上得到了提升。但是PyPy无法支持官方的C/Python API，无法使用Numpy或Scipy等第三方库。</p>
</blockquote></li>
</ul>
<blockquote>

</blockquote>
<ul>
<li><p>多进程、多线程、协程</p></li>
<li><p>多个if elif条件判断，可以把最优可能先发生的条件放到前面写，这样减少判断次数</p></li>
</ul>
<h2 id="python中的命名方式魔法方法">8. python中的命名方式、魔法方法</h2>
<p><strong>Python中一切皆对象，</strong>函数也不例外，函数作为对象可以赋值给一个变量、可以作为元素添加到集合对象中、可作为参数值传递给其它函数，还可以当做函数的返回值，这些特性就是第一类对象所特有的。</p>
<figure>
<img src="https://img-blog.csdn.net/20180122142356120?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmVpa29uMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="命名规约" /><figcaption>命名规约</figcaption>
</figure>
<p><strong>public类型</strong></p>
<ol type="1">
<li>xx : 公用方法，公有变量没有以下划线开头的变量或者方法是public类型。</li>
<li>public类型可以被子类、类内以及类外被访问。</li>
<li>在python中数据和方法默认都是pubic类型的，此时方法和变量名都没有下划线。</li>
</ol>
<p><strong>protected类型</strong></p>
<ol type="1">
<li>_xx : 半保护方法, 以单下划线开头表示的是protected类型的变量或者方法。</li>
<li>只有类对象和子类对象自己能够访问到这些变量，在模块或类外不可以使用，不能用from module import *导入，为了避免和子类的方法名称冲突，对于该标识符描述的方法，父类的方法不能轻易地被子类方法覆盖，他们的名字实际上是_classname_methodname</li>
</ol>
<p><strong>private类型</strong></p>
<p>1、 __xx :全私有，全保护，双下划线表示的是私有类型的变量或者方法。 2、private类型只能允许类内进行访问。 只能类对象自己访问，不能用from module import *导入。</p>
<p><strong>除此以外</strong></p>
<ul>
<li><strong>__object__ </strong> 内建方法，用户不要定义，python中的魔方方法</li>
<li><strong>xx_:</strong>用于避免和Python关键词冲突</li>
</ul>
<p><strong>魔方方法</strong></p>
<p>在Python中以<strong>两个下划线开头的方法</strong>，__init__、__str__、__doc__、__new__等，被称为&quot;魔术方法&quot;（Magic methods）。魔术方法在类或对象的某些事件出发后会自动执行，如果希望根据自己的程序定制自己特殊功能的类，那么就需要对这些方法进行重写。注意：Python 将所有以 __（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 __ 为前缀。</p>
<ol type="1">
<li>__new__：
<ul>
<li>在<strong>实例创建前被调用</strong>，其任务为创建实例然后返回该实例对象，是个<strong>静态方法</strong>创建对象时候执行的方法。</li>
<li><strong>至少有一个参数cls，代表当前类</strong>，此参数在实例化时由python自动识别</li>
<li><strong>必须要有返回值</strong>，返回实例化出的实例，返回值（实例）将传递给init方法的第一个参数（self）</li>
</ul></li>
<li>__init__:
<ul>
<li>当<strong>实例对象创建完后被调用</strong>，然后设置对象属性的一些初始值，通常用在初始化一个类实例的时候，是一个实例方法。</li>
<li>init有一个参数self,这就是new返回的实例，init可以在new基础上完成一些其他初始化的动作，</li>
<li><strong>Init不需要返回值</strong></li>
</ul></li>
<li><p>__str__：使用Print输出对象的时候，只要自己定义了str方法，就会打印从这个方法中return的数据</p></li>
<li><p>__del__：删除对象执行的方法</p></li>
</ol>
<h2 id="python引用计数机制-垃圾回收机制-gc模块">9. python引用计数机制 垃圾回收机制 gc模块</h2>
<p>https://foofish.net/python-gc.html 这个博客讲的不错</p>
<p><strong>垃圾回收</strong></p>
<ul>
<li><p><strong>垃圾回收机制定义：</strong></p>
<p>垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要总启动垃圾回收。所以，Python只会在特定条件下，自动启动垃圾回收。当Python运行时，<strong>会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数</strong>，当两者的差值高于某个阈值时，垃圾回收才会启动。我们可以通过gc模块的get_threshold()方法，查看该阈值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">print(gc.get_threshold())</span><br></pre></td></tr></table></figure>
<p>返回(700, 10, 10)，后面的两个10是与分代回收相关的阈值，后面可以看到。700即是垃圾回收启动的阈值。可以通过gc中的set_threshold()方法重新设置。我们也可以手动启动垃圾回收，即使用gc.collect()。</p></li>
<li><p><strong>垃圾回收作用：</strong></p>
<ul>
<li>找到内存中无用的垃圾资源</li>
<li>清除这些垃圾并把内存让出来给其他对象使用</li>
<li>解决内存泄露问题：内存空间在使用完毕后未释放</li>
</ul></li>
</ul>
<p><strong>引用计数</strong>（Reference Counting）：</p>
<ul>
<li><p>引用计数定义及使用过程</p>
<ul>
<li><p>每个对象维护一个<code>ob_ref</code>字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，一旦对象的引<strong>用计数为0</strong>，该对象<strong>立即被回收，对象占用的内存空间将被释放</strong>。</p></li>
<li><p>引用次数增加：创建对象，对象被引用（赋值操作），对象作为参数传递到函数，对象作为元素存储到容器中。</p></li>
<li><p>它的<strong>缺点是</strong>需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是它不能解决对象的<strong>“循环引用”</strong>，因此，也有很多语言比如Java并没有采用该算法做来垃圾的收集机制。</p></li>
</ul></li>
<li><p><strong>循环引用</strong>：</p>
<ul>
<li><p>会使得引用对象的引用计数不能为0，然而这些对象实际上并没有被任何外部对象所引用，他们只是相互引用，A和B<strong>相互引用</strong>而再没有外部引用A与B中的任何一个，它们的引用计数虽然都为1，但显然应该被回收，例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">a = &#123;&#125; <span class="comment"># A引用计数为1</span></span><br><span class="line">b = &#123;&#125; <span class="comment"># B引用计数为2</span></span><br><span class="line">a[<span class="string">'b'</span>] = b <span class="comment"># B引用计数加1</span></span><br><span class="line">b[<span class="string">'a'</span>] = a <span class="comment"># A引用计数加1</span></span><br><span class="line">print(sys.getrefcount(a)) <span class="comment">#获取引用计数 输出为3因为a作为参数传给了getrefecount</span></span><br><span class="line">print(sys.getrefcount(b)) <span class="comment">#输出为3</span></span><br><span class="line"><span class="keyword">del</span> a <span class="comment"># a引用计数减一</span></span><br><span class="line"><span class="keyword">del</span> b <span class="comment"># b引用计数减一</span></span><br></pre></td></tr></table></figure>
<p>上述例子中，执行完del语句后，没有任何引用指向这两个对象，但是两个对象各包含一个对方对象的引用，但是都不能使用了，就可以理解为垃圾对象，但是引用计数都不为0，就不会被回收，留在内存中，就<strong>造成了内存泄露。由此引入标记-清楚和分代（隔代）回收两种gc机制</strong></p></li>
</ul></li>
</ul>
<p><strong>垃圾回收机制具体实现</strong></p>
<ul>
<li><p><strong>标记清楚</strong>（Mark-Sweep）</p>
<ul>
<li>标记清除（Mark—Sweep）算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：
<ul>
<li><strong>标记阶段</strong>：GC把所有的『活动对象』打上标记</li>
<li><strong>回收阶段：</strong>把那些没有标记的对象『非活动对象』进行回收。</li>
</ul></li>
</ul>
<blockquote>
<p><strong>那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？</strong></p>
<p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。<strong>根对象就是全局变量、调用栈、寄存器。</strong></p>
</blockquote>
<ul>
<li><p>举例：</p>
<p>把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。</p></li>
</ul>
<p><img src="https://i.loli.net/2020/08/26/mEMZXS94Kv7qTBW.png" /></p>
<ul>
<li><p><strong>标记清除算法主要用处：</strong></p>
<p>作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于<strong>字符串、数值对象是不可能造成循环引用问题</strong>。Python使用一个双向链表将这些容器对象组织起来。</p></li>
<li><p>缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。</p></li>
</ul></li>
<li><p><strong>分代回收</strong></p>
<p>这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，<strong>对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。</strong></p>
<p>Python将<strong>所有的对象分为0，1，2三代</strong>。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。</p>
<p>这两个次数即上面get_threshold()返回的(700, 10, 10)返回的两个10。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。</p>
<p>同样可以用set_threshold()来调整，比如对2代对象进行更频繁的扫描。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">gc.set_threshold(<span class="number">700</span>, <span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>分代回收是一种以空间换时间的操作方式，Python<strong>将内存根据对象的存活时间划分为不同的集合</strong>，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代<strong>链表的总数达到上限</strong>时，<strong>Python垃圾收集机制就会被触发</strong>，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，<strong>分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象</strong></p></li>
<li><p>还有两种情况会触发GC机制：</p>
<ul>
<li><p>程序退出</p></li>
<li><p>调用gc.collect</p></li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">gc.collect()</span><br><span class="line"><span class="comment"># 可以导入gc模块，时不时的回收内存，释放内存空间，充分利用分配的内存，避免程序跑到一半停止</span></span><br></pre></td></tr></table></figure>
<h2 id="内存管理机制">10. 内存管理机制</h2>
<ul>
<li>python中的内存管理由<strong>Python私有堆空间管理。</strong>所有Python对象和数据结构都位于私有堆中。程序员无权访问此私有堆。python解释器负责处理这个问题。</li>
</ul>
<p><strong>Python对象的堆空间分配由Python的内存管理器完成</strong>。核心API提供了一些程序员编写代码的工具。</p>
<p>Python还有一个内置的垃圾收集器，它可以回收所有未使用的内存，并使其可用于堆空间。</p>
<p><strong>Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。</strong></p>
<p>1，<strong>Pymalloc机制</strong>。为了加速Python的执行效率，Python<strong>引入了一个内存池机制</strong>，<strong>用于管理对小块内存的申请和释放</strong>。</p>
<p>2，Python中<strong>所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。</strong></p>
<p>3，对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就发不能再分配给浮点数。<strong>Python 对小整数的定义是 [-5, 257)</strong>，对于这个范围的数，不会新建对象，直接从小整数对象池中取就可以。</p>
<h2 id="文件打开模式">11. 文件打开模式</h2>
<p><code>text = oepn(filePath, 操作方式，编码方式）</code></p>
<p><img src="https://i.loli.net/2020/09/03/I8DlkJKPVAwjR9W.png" /></p>
<h2 id="单例模式">12. 单例模式</h2>
<p><strong>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，单例模式是一种对象创建型模式</strong>。简单的说就是保证只有一个对象，节约内存空间，我们可以通过修改类中的 <code>__new__</code>方法，实现一个简单的单例类。</p>
<p>什么情况下会用到：假如有很多地方都需要使用配置文件的内容，也就是说，很多地方都需要创建 AppConfig对象的实例，这就导致系统中存在多个AppConfig的实例对象，在配置文件内容很多的情况下会严重浪费内存资源。类似AppConfig这样的类，我们希望在程序运行期间只存在一个实例对象。</p>
<p>优点：速度快、在使用时不需要创建、直接使用即可。</p>
<p>缺点：可能存在内存浪费</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A.instance:</span><br><span class="line">            A.instance = super().__new__(cls)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">a = A()</span><br><span class="line">print(id(a))</span><br><span class="line">b = A()</span><br><span class="line">print(id(b))</span><br></pre></td></tr></table></figure>
<h2 id="python函数的嵌套闭包">13. python函数的嵌套、闭包</h2>
<ul>
<li><p><strong>函数嵌套</strong>：python允许在定义函数的时候，其函数体内又包含另外一个函数的完整定义。像这样定义在其他函数内的函数叫做内部函数，内部函数所在的函数叫做外部函数。</p></li>
<li><p><strong>自由变量</strong>：未在本地作用域中定义的变量。例如定义在内存函数外的外层函数的作用域中的变量。</p></li>
<li><p><strong>闭包</strong>：在一个外函数中定义一个内函数，<strong>内函数运用了外函数的临时变量</strong>，并且<strong>外函数的返回值是内函数的引用</strong>，这样就构成了一个闭包。</p>
<ul>
<li>闭包函数必须满足两个条件:1.函数内部定义的函数 <strong>2.包含对外部作用域而非全局作用域的引用</strong></li>
<li>闭包函数的特点：1.自带作用域 2.延迟计算</li>
</ul>
<p><em>一般情况下，函数结束，会释放内部变量，但是闭包情况下，如果外部函数结束发现自己有临时变量将来会在内部函数用到，就把这个临时变量绑定给了内部函数，然后自己在结束</em></p></li>
<li><p><strong>一些例子</strong></p>
<ul>
<li>外层函数返回的是一个函数名的话，就返回‘第一层’</li>
</ul>
<p><img src="https://i.loli.net/2020/08/26/nfJUcdbuEFA1jW6.png" /></p>
<ul>
<li>外层函数返回的是函数调用的话，结果为 第一层 第二层</li>
</ul>
<p><img src="https://i.loli.net/2020/08/26/EyLGI6zfUqe38JT.png" /></p>
<ul>
<li><p>外部函数定义一个数值变量，形成闭包需要加入nonlocal<img src="https://i.loli.net/2020/08/26/lThZ967xImDbiaQ.png" /></p></li>
<li><p>其他情况下定义某个对象直接可以传入内部函数，只有再次调用函数f才能输出闭包内函数的结果</p></li>
</ul></li>
</ul>
<p><img src="https://i.loli.net/2020/08/26/rPMxhA56gbQBo2u.png" /></p>
<h2 id="python装饰器生成器迭代器">14. python装饰器、生成器、迭代器</h2>
<p><strong>一、装饰器</strong></p>
<p>函数可以作为参数传递，常用作<strong>插入日志、性能测试、事务处理、缓存和权限校验等场景</strong>。其方式为<strong>外部函数传入被装饰函数名，内部函数返回装饰函数名</strong>。（<em>大白话说感觉就是有一个函数被另一个函数修饰了一下</em>）</p>
<ul>
<li><p>应用场景：</p>
<ul>
<li><p>日志</p></li>
<li><p>表单验证</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_validate</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(args[<span class="number">0</span>], str):</span><br><span class="line">            <span class="comment"># isinstance(参数1，参数2),如果1和2类型相同，返回True,否则为False</span></span><br><span class="line">            <span class="keyword">raise</span> BaseException(<span class="string">"first argument need string"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">@pre_validate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate_string</span><span class="params">(string)</span>:</span></span><br><span class="line">    print(string)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">validate_string(<span class="string">'required'</span>)</span><br><span class="line">validate_string(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>特点：</p>
<ul>
<li>1.不修改被装饰函数的调用方式<br />
</li>
<li>2.不修改被装饰函数的源代码</li>
<li>3.为待装饰函数增加额外的功能</li>
<li>4.返回值为已装饰的函数对象</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种是最简单的，但是fun不能传参，也不能返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(fun)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'开始执行'</span>)</span><br><span class="line">        t1 = time.time()</span><br><span class="line">        fun()</span><br><span class="line">        t2 = time.time()</span><br><span class="line">        print(<span class="string">'打印任务完成，耗费时间为 &#123;:.4&#125;(s)'</span>.format(t2-t1))</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果希望fun能返回一个值, 必须在修饰器里先存储一下，在返回</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(fun)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'开始执行'</span>)</span><br><span class="line">        t1 = time.time()</span><br><span class="line">        result = fun() <span class="comment"># 返回结果为一个随机的元组</span></span><br><span class="line">        t2 = time.time()</span><br><span class="line">        print(<span class="string">'打印任务完成，耗费时间为 &#123;:.4&#125;(s)'</span>.format(t2-t1))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 如果fun能传参数和返回值    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(fun)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'开始执行'</span>)</span><br><span class="line">        t1 = time.time()</span><br><span class="line">        result = fun(*args, **kwargs)</span><br><span class="line">        t2 = time.time()</span><br><span class="line">        print(<span class="string">'\n'</span>)</span><br><span class="line">        print(<span class="string">'打印任务完成，耗费时间为 &#123;:.4&#125;(s)'</span>.format(t2-t1))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@dec</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        print(i, end = <span class="string">' '</span>)</span><br><span class="line">    <span class="keyword">return</span> num+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">n = fun(<span class="number">1000</span>) </span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure>
<p><strong>二、生成器与迭代器</strong></p>
<p><img src="https://img-blog.csdn.net/20170516000644044?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamluaXhpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" /></p>
<blockquote>
<p>可迭代对象包含迭代器。 如果一个对象拥有__iter__方法，其是可迭代对象；如果一个对象拥有next方法，其是迭代器。 定义可迭代对象，必须实现__iter__方法；定义迭代器，必须实现__iter__和next方法。</p>
</blockquote>
<ul>
<li><strong>迭代器</strong>
<ul>
<li>可遍历和迭代的对象</li>
<li>可以被next()函数调用并不断返回下一个值的对象称为迭代器</li>
<li>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束；迭代器只能往前不会后退。</li>
<li>迭代器有两个基本的方法：<strong>iter()和next()</strong> iter返回的是当前对象的迭代器类的实例</li>
<li>可以使用<strong>isinstance()</strong>判断一个对象是否是迭代器对象(iterator)</li>
<li>python3中 <strong>range(n)生成的是迭代器对象</strong>；Python2中<strong>xrange(n)生成的才是迭代器对象</strong>？？？</li>
</ul></li>
<li><p><strong>生成器</strong></p>
<ul>
<li><p>自动实现了迭代器协议，即iter和next方法，<strong>生成器在迭代的过程中可以改变当前迭代值，而修改普通迭代器的当前迭代值往往会发生异常</strong>，影响程序的执行。</p></li>
<li>生成器的本质就是迭代器。生成器包括两种:<strong>生成器函数和生成器表达式</strong>
<ul>
<li><strong>生成器函数：</strong>一个包含yield关键字的函数就是一个生成器函数。并且yield不能和return共用，并且yield只能用在函数内。yield语句一次返回一个结果，在每个结果中间，挂起函数的状态，以便下次重它离开的地方继续执行
<ul>
<li>生成器函数执行之后会得到一个生成器作为返回值，并不会执行函数体。</li>
<li>执行了__next__()方法之后才会执行函数体，并且获得返回值。</li>
<li>next()内置方法，内部调用生成器函数的__next__()方法。</li>
<li>yield和return相同的是可以返回值，但是不同的是<strong>yield 不会结束函数</strong></li>
</ul></li>
<li><strong>生成器表达式</strong>：类似于列表推导，但是，生成器返回<strong>按需产生</strong>结果的一个对象，而不是一次构建一个结果列表，按需取出对象。注意生成器用()包裹起来，可以节省内存。</li>
</ul></li>
<li><p><strong>生成器作用</strong>：可以实现多任务(协程--&gt;模拟并发)。</p></li>
</ul></li>
</ul>
<blockquote>
<p>生成器类似于一种数据类型，这种数据类型自动实现了迭代器协议，所以生成器也是迭代器。</p>
</blockquote>
<ul>
<li>生成器实例</li>
</ul>
<p><img src="https://i.loli.net/2020/08/26/UcwIlK8XBT6oOLu.png" /></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    cur = <span class="number">1</span></span><br><span class="line">    pre = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">yield</span> pre</span><br><span class="line">        pre, cur = cur, cur + pre</span><br><span class="line">g = fib(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<h2 id="python类可以定义哪几种方法静态方法和类应用场景">15. Python类可以定义哪几种方法：静态方法和类应用场景</h2>
<p><img src="https://i.loli.net/2020/09/05/hEDdqnaArXiIUgF.png" /></p>
<p>python中实现静态方法和类方法都是依赖于python的装饰器来实现的。 对象方法有self参数，类方法有cls参数，静态方法不需要这些附加参数。</p>
<ul>
<li>静态方法</li>
</ul>
<p>要在类中使用静态方法，需在类成员函数前面加上@staticmethod标记符，以表示下面的成员函数是静态函数。使用静态方法的好处是，<strong>不需要定义实例即可使用这个方法</strong>。另外，<strong>多个实例共享此静态方法</strong>（静态方法无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系，简单讲，静态方法就是放在一个类的作用域里的函数而已）。</p>
<p>一般用于和类对象以及实例对象无关的代码。不需要传递参数，但是还想归为自己的一类，举例子，创建一个三角形类，一个正方向类，判断能否构成这样的类，在两个类对象中分别加入一个静态方法用于各自的判断</p>
<ul>
<li>类方法</li>
</ul>
<p>类方法与普通的成员函数和静态函数有不同之处。定义： 一个类方法就可以<strong>通过类或它的实例来调用的方法,</strong> 不管你是用类来调用这个方法还是类实例调用这个方法,<strong>该方法的第一个参数总是定义该方法的类对象。</strong> 也即是方法的第一个参数都是类对象而不是实例对象. 按照习惯，类方法的第一个形参被命名为 <code>cls</code>。任何时候定义类方法都不是必须的（类方法能实现的功能都可以通过定义一个普通函数来实现,只要这个函数接受一个类对象做为参数就可以了）。同时，类方法可以访问类属性，无法访问实例属性。上述的变量grade，在类里是类变量，在实例中又是实例变量，所以使用的时候要注意，使用好的话功能很强大，使用不好容易混淆。</p>
<p>当一个方法中只涉及到静态属性的时候可以使用类方法(类方法用来修改类属性)</p>
<h2 id="init__函数init.py的区别">16. __init__函数，<strong>init</strong>.py的区别</h2>
<p>一个包是一个带有特殊文件 <code>__init__.py</code> 的目录。<code>__init__.py</code> 文件定义了包的属性和方法。其实它可以什么也不定义；可以只是一个空文件，但是必须存在。如果 <code>__init__.py</code> 不存在，这个目录就仅仅是一个目录，而不是一个包，它就不能被导入或者包含其它的模块和嵌套包。</p>
<p>发现在引入package的过程中，<strong>init</strong>.py会运行，因此，如果某些变量或方法需要常驻内存，可以将它们写入<strong>init</strong>.py文件中。</p>
<p><strong>init</strong>.py 中还有一个重要的变量，叫做 <strong>all</strong>。我们有时会使出一招“全部导入”，也就是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from PackageName import *</span><br></pre></td></tr></table></figure>
<h2 id="怎样调用父类方法">17. 怎样调用父类方法</h2>
<ol type="1">
<li>直接写类名调用</li>
<li>用 super(type, obj).method(arg)方法调用。</li>
</ol>
<h2 id="base64">18. Base64</h2>
<p>简介：Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符（包括a-z、A-Z、0-9、/、+）来表示二进制数据的方法。Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。</p>
<p>base64 并不是用来加密数据，而是实现在文本协议中传递二进制内容。如 html mime</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">plaintext=<span class="string">"aaa"</span> <span class="comment"># 明文为aaa</span></span><br><span class="line">s=base64.b64encode(plaintext.encode()) <span class="comment"># 这里的s是字节码,编码的过程中,参数只能是字节码</span></span><br><span class="line">print(s)</span><br><span class="line">t=base64.b64decode(s) <span class="comment"># 这里t的类型是字节码,这也是python的缺点,许多数据类型不明确.解码的过程中参数可以是字符串也可以是字节码</span></span><br><span class="line">print(t) <span class="comment"># t是s解码后的字节码</span></span><br><span class="line">print(t.decode()) <span class="comment"># 输出的是plaintext</span></span><br></pre></td></tr></table></figure>
<h2 id="python的反射机制">19. python的反射机制</h2>
<p><strong>反射</strong>就是通过字符串的形式，导入模块；通过字符串的形式，去模块寻找指定函数，并执行。利用字符串的形式去对象（模块）中操作（查找/获取/删除/添加）成员，<strong>一种基于字符串的事件驱动！</strong></p>
<p>https://www.cnblogs.com/Guido-admirers/p/6206212.html</p>
<h2 id="什么是pythonpath">20. 什么是PYTHONPATH？</h2>
<p>Pythonpath是导入模块时使用的环境变量。每当导入模块时，也会查找PYTHONPATH以检查各个目录中是否存在导入的模块。解释器使用它来确定要加载的模块。</p>
<p>PYTHONPATH是Python中一个重要的环境变量,用于在导入模块的时候搜索路径</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</span><br><span class="line">[<span class="string">''</span>, <span class="string">'/usr/lib/python2.7'</span>, <span class="string">'/usr/lib/python2.7/plat-x86_64-linux-gnu'</span>,</span><br><span class="line"> <span class="string">'/usr/lib/python2.7/lib-tk'</span>, <span class="string">'/usr/lib/python2.7/lib-old'</span>, </span><br><span class="line"><span class="string">'/usr/lib/python2.7/lib-dynload'</span>, <span class="string">'/usr/local/lib/python2.7/dist-packages'</span>,</span><br><span class="line"> <span class="string">'/usr/lib/python2.7/dist-packages'</span>, <span class="string">'/usr/lib/python2.7/dist-packages/PILcompat'</span>, </span><br><span class="line"><span class="string">'/usr/lib/python2.7/dist-packages/gtk-2.0'</span>, <span class="string">'/usr/lib/pymodules/python2.7'</span>,</span><br><span class="line"> <span class="string">'/usr/lib/python2.7/dist-packages/ubuntu-sso-client'</span>]</span><br></pre></td></tr></table></figure>
<p>可以看到,路径列表的第一个元素为空字符串,<strong>代表的是相对路径下的当前目录.</strong></p>
<p>由于在导入模块的时候,解释器会按照列表的顺序搜索,直到找到第一个模块,所以优先导入的模块为同一目录下的模块.</p>
<p>导入模块时搜索路径的顺序也可以改变.这里分两种情况:</p>
<p>1,通过sys.path.append(),sys.path.insert()等方法来改变,这种方法当重新启动解释器的时候,原来的设置会失效.</p>
<p>2,改变PYTHONPATH,这种设置方法永久有效:</p>
<p>在这种情况下,可以通过在sys.path列表显示的路径中<a href="https://docs.python.org/3/install/index.html#modifying-python-s-search-path" target="_blank" rel="noopener">添加.pth文件</a>来实现</p>
<hr />
<p>今日分享结束～</p>

    </div>

    
    
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-hand-peace-o"></i>感谢您的阅读-------------</div>
    
</div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Amanda Z
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://zymdragonggg.github.io/2020/10/13/python%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/" title="python面试知识点总结（二）">http://zymdragonggg.github.io/2020/10/13/python面试知识点总结（二）/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/python/" rel="tag"><i class="fa fa-tag"></i> python</a>
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"><i class="fa fa-tag"></i> 面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/07/python%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/" rel="prev" title="python面试知识点总结（一）">
      <i class="fa fa-chevron-left"></i> python面试知识点总结（一）
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#gil及多线程相关"><span class="nav-text">1. GIL及多线程相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python多线程多进程实践"><span class="nav-text">2. python多线程、多进程实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map函数和reduce函数"><span class="nav-text">3. map函数和reduce函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python中断言"><span class="nav-text">4. python中断言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python2和3的区别"><span class="nav-text">5. Python2和3的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常捕获和处理"><span class="nav-text">6. 异常捕获和处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#提高python运行效率的方法"><span class="nav-text">7. 提高python运行效率的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python中的命名方式魔法方法"><span class="nav-text">8. python中的命名方式、魔法方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python引用计数机制-垃圾回收机制-gc模块"><span class="nav-text">9. python引用计数机制 垃圾回收机制 gc模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理机制"><span class="nav-text">10. 内存管理机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件打开模式"><span class="nav-text">11. 文件打开模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单例模式"><span class="nav-text">12. 单例模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python函数的嵌套闭包"><span class="nav-text">13. python函数的嵌套、闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python装饰器生成器迭代器"><span class="nav-text">14. python装饰器、生成器、迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python类可以定义哪几种方法静态方法和类应用场景"><span class="nav-text">15. Python类可以定义哪几种方法：静态方法和类应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#init__函数init.py的区别"><span class="nav-text">16. __init__函数，init.py的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎样调用父类方法"><span class="nav-text">17. 怎样调用父类方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#base64"><span class="nav-text">18. Base64</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python的反射机制"><span class="nav-text">19. python的反射机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是pythonpath"><span class="nav-text">20. 什么是PYTHONPATH？</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Amanda Z"
      src="/images/dragon.png">
  <p class="site-author-name" itemprop="name">Amanda Z</p>
  <div class="site-description" itemprop="description">Don not look up to others. I am also a landscape :)</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zymdragonggg" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zymdragonggg" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:714977076@qq.com" title="E-Mail → mailto:714977076@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      推荐阅读
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://stepneverstop.github.io/" title="http:&#x2F;&#x2F;stepneverstop.github.io" rel="noopener" target="_blank">Keavnn</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Amanda Z</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">71k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:05</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>






  <script src="//code.tidio.co/0uq3ebmd2rkasldxtojlcbdal0xwqyzj.js"></script>







  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'ApyLTspLca1xPfsGb4mL0X55-gzGzoHsz',
      appKey     : 'NH1fSMzPzNaWst44tEiTq2bo',
      placeholder: "Just say sth.",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
